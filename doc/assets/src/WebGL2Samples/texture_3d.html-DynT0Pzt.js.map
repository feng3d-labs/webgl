{"version":3,"file":"texture_3d.html-DynT0Pzt.js","sources":["../../../../examples/src/WebGL2Samples/texture_3d.ts"],"sourcesContent":["import { reactive } from '@feng3d/reactivity';\nimport { CanvasContext, RenderObject, RenderPass, RenderPipeline, Sampler, Texture, VertexAttributes } from '@feng3d/render-api';\nimport { WebGL } from '@feng3d/webgl';\nimport { snoise } from './third-party/noise3D';\nimport { getShaderSource } from './utility';\n\n(function ()\n{\n    const canvas = document.createElement('canvas');\n\n    canvas.id = 'glcanvas';\n    canvas.width = Math.min(window.innerWidth, window.innerHeight);\n    canvas.height = canvas.width;\n    document.body.appendChild(canvas);\n\n    const rc: CanvasContext = { canvasId: 'glcanvas', webGLcontextId: 'webgl2' };\n    const webgl = new WebGL(rc);\n\n    // -- Divide viewport\n\n    const windowSize = {\n        x: canvas.width,\n        y: canvas.height,\n    };\n\n    const Corners = {\n        TOP_LEFT: 0,\n        TOP_RIGHT: 1,\n        BOTTOM_RIGHT: 2,\n        BOTTOM_LEFT: 3,\n        MAX: 4,\n    };\n\n    const viewport: { x: number, y: number, z: number, w: number }[] = new Array(Corners.MAX);\n\n    viewport[Corners.BOTTOM_LEFT] = {\n        x: 0,\n        y: 0,\n        z: windowSize.x / 2,\n        w: windowSize.y / 2,\n    };\n\n    viewport[Corners.BOTTOM_RIGHT] = {\n        x: windowSize.x / 2,\n        y: 0,\n        z: windowSize.x / 2,\n        w: windowSize.y / 2,\n    };\n\n    viewport[Corners.TOP_RIGHT] = {\n        x: windowSize.x / 2,\n        y: windowSize.y / 2,\n        z: windowSize.x / 2,\n        w: windowSize.y / 2,\n    };\n\n    viewport[Corners.TOP_LEFT] = {\n        x: 0,\n        y: windowSize.y / 2,\n        z: windowSize.x / 2,\n        w: windowSize.y / 2,\n    };\n\n    // -- Initialize texture\n\n    // Note By @kenrussel: The sample was changed from R32F to R8 for best portability.\n    // not all devices can render to floating-point textures\n    // (and, further, this functionality is in a WebGL extension: EXT_color_buffer_float),\n    // and renderability is a requirement for generating mipmaps.\n\n    const SIZE = 32;\n    const data = new Uint8Array(SIZE * SIZE * SIZE);\n\n    for (let k = 0; k < SIZE; ++k)\n    {\n        for (let j = 0; j < SIZE; ++j)\n        {\n            for (let i = 0; i < SIZE; ++i)\n            {\n                data[i + j * SIZE + k * SIZE * SIZE] = snoise([i, j, k]) * 256;\n            }\n        }\n    }\n\n    const texture: Texture = {\n        descriptor: {\n            size: [SIZE, SIZE, SIZE],\n            dimension: '3d',\n            format: 'r8unorm',\n            generateMipmap: true,\n        },\n        sources: [{ __type__: 'TextureDataSource', mipLevel: 0, size: [SIZE, SIZE, SIZE], data }],\n    };\n    const sampler: Sampler = {\n        lodMinClamp: 0,\n        lodMaxClamp: Math.log2(SIZE),\n        minFilter: 'linear',\n        magFilter: 'linear',\n        mipmapFilter: 'linear',\n    };\n\n    // -- Initialize program\n    const program: RenderPipeline = { vertex: { code: getShaderSource('vs') }, fragment: { code: getShaderSource('fs') } };\n\n    // -- Initialize buffer\n    const positions = new Float32Array([\n        -1.0, -1.0,\n        1.0, -1.0,\n        1.0, 1.0,\n        1.0, 1.0,\n        -1.0, 1.0,\n        -1.0, -1.0,\n    ]);\n\n    const texCoords = new Float32Array([\n        0.0, 1.0,\n        1.0, 1.0,\n        1.0, 0.0,\n        1.0, 0.0,\n        0.0, 0.0,\n        0.0, 1.0,\n    ]);\n\n    // -- Initilize vertex array\n\n    const vertexArray: { vertices?: VertexAttributes } = {\n        vertices: {\n            position: { data: positions, format: 'float32x2' },\n            in_texcoord: { data: texCoords, format: 'float32x2' },\n        },\n    };\n\n    // -- Render\n\n    const orientation = [0.0, 0.0, 0.0];\n\n    requestAnimationFrame(render);\n\n    function yawPitchRoll(yaw, pitch, roll)\n    {\n        const cosYaw = Math.cos(yaw);\n        const sinYaw = Math.sin(yaw);\n        const cosPitch = Math.cos(pitch);\n        const sinPitch = Math.sin(pitch);\n        const cosRoll = Math.cos(roll);\n        const sinRoll = Math.sin(roll);\n\n        return [\n            cosYaw * cosPitch,\n            cosYaw * sinPitch * sinRoll - sinYaw * cosRoll,\n            cosYaw * sinPitch * cosRoll + sinYaw * sinRoll,\n            0.0,\n            sinYaw * cosPitch,\n            sinYaw * sinPitch * sinRoll + cosYaw * cosRoll,\n            sinYaw * sinPitch * cosRoll - cosYaw * sinRoll,\n            0.0,\n            -sinPitch,\n            cosPitch * sinRoll,\n            cosPitch * cosRoll,\n            0.0,\n            0.0, 0.0, 0.0, 1.0,\n        ];\n    }\n\n    const ro: RenderObject = {\n        pipeline: program,\n        bindingResources: {\n            diffuse: { texture, sampler },\n        },\n        vertices: vertexArray.vertices,\n        draw: { __type__: 'DrawVertex', vertexCount: 6 },\n    };\n\n    const renderPassObjects: RenderObject[] = [];\n\n    for (let i = 0; i < Corners.MAX; ++i)\n    {\n        renderPassObjects.push({\n            ...ro,\n            viewport: { x: viewport[i].x, y: viewport[i].y, width: viewport[i].z, height: viewport[i].w },\n        });\n    }\n\n    const rp: RenderPass = {\n        descriptor: { colorAttachments: [{ clearValue: [0.0, 0.0, 0.0, 1.0], loadOp: 'clear' }] },\n        renderPassObjects,\n    };\n\n    function render()\n    {\n        orientation[0] += 0.020; // yaw\n        orientation[1] += 0.010; // pitch\n        orientation[2] += 0.005; // roll\n\n        const yawMatrix = new Float32Array(yawPitchRoll(orientation[0], 0.0, 0.0));\n        const pitchMatrix = new Float32Array(yawPitchRoll(0.0, orientation[1], 0.0));\n        const rollMatrix = new Float32Array(yawPitchRoll(0.0, 0.0, orientation[2]));\n        const yawPitchRollMatrix = new Float32Array(yawPitchRoll(orientation[0], orientation[1], orientation[2]));\n        const matrices = [yawMatrix, pitchMatrix, rollMatrix, yawPitchRollMatrix];\n\n        for (let i = 0; i < Corners.MAX; ++i)\n        {\n            reactive(renderPassObjects[i].bindingResources).orientation = { value: matrices[i] };\n        }\n\n        webgl.submit({ commandEncoders: [{ passEncoders: [rp] }] });\n\n        requestAnimationFrame(render);\n    }\n})();\n"],"names":["canvas","rc","webgl","WebGL","windowSize","Corners","viewport","SIZE","data","k","j","i","snoise","texture","sampler","program","getShaderSource","positions","texCoords","vertexArray","orientation","render","yawPitchRoll","yaw","pitch","roll","cosYaw","sinYaw","cosPitch","sinPitch","cosRoll","sinRoll","ro","renderPassObjects","rp","yawMatrix","pitchMatrix","rollMatrix","yawPitchRollMatrix","matrices","reactive"],"mappings":"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"}