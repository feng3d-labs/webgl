{"version":3,"file":"fractalCube.html-D5UL05a2.js","sources":["../../../../examples/src/test/fractalCube.ts"],"sourcesContent":["import { reactive } from '@feng3d/reactivity';\nimport { CanvasContext, RenderObject, Sampler, Submit, Texture } from '@feng3d/render-api';\nimport { WebGL } from '@feng3d/webgl';\nimport { mat4 } from 'gl-matrix';\n\nlet cubeRotation = 0.0;\n\nmain();\n\n//\n// Start here\n//\nasync function main()\n{\n    const canvas = document.querySelector('#glcanvas') as HTMLCanvasElement;\n    const devicePixelRatio = window.devicePixelRatio || 1;\n\n    canvas.width = canvas.clientWidth * devicePixelRatio;\n    canvas.height = canvas.clientHeight * devicePixelRatio;\n\n    const renderingContext: CanvasContext = { canvasId: 'glcanvas', webGLcontextId: 'webgl2' };\n\n    const webgl = new WebGL(renderingContext);\n\n    // Here's where we call the routine that builds all the\n    // objects we'll be drawing.\n    const buffers = initBuffers();\n\n    const texture: {\n        texture: Texture;\n        sampler: Sampler;\n    } = { texture: { descriptor: { size: [canvas.width, canvas.height] } }, sampler: {} };\n\n    const renderObject: RenderObject = {\n        pipeline: {\n            vertex: {\n                code: `\n        attribute vec4 aVertexPosition;\n        attribute vec2 aTextureCoord;\n    \n        uniform mat4 uModelViewMatrix;\n        uniform mat4 uProjectionMatrix;\n    \n        varying highp vec2 vTextureCoord;\n        varying highp vec4 v_fragPosition;\n    \n        void main(void) {\n          gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\n          vTextureCoord = aTextureCoord;\n          v_fragPosition = 0.5 * (aVertexPosition + vec4(1.0, 1.0, 1.0, 1.0));\n        }\n      ` }, fragment: {\n                code: `\n        precision highp float;\n        precision highp int;\n\n        varying highp vec2 vTextureCoord;\n        varying highp vec4 v_fragPosition;\n    \n        uniform sampler2D uSampler;\n    \n        void main(void) {\n          vec4 color = texture2D(uSampler, vTextureCoord) * v_fragPosition;\n          gl_FragColor = color;\n        }\n      ` },\n            primitive: { topology: 'triangle-list' },\n            depthStencil: { depthCompare: 'less-equal' },\n        },\n        vertices: {\n            aVertexPosition: {\n                format: 'float32x3',\n                data: buffers.position,\n            },\n            aTextureCoord: {\n                format: 'float32x2',\n                data: buffers.textureCoord,\n            },\n        },\n        indices: buffers.indices,\n        draw: { __type__: 'DrawIndexed', firstIndex: 0, indexCount: 36 },\n        bindingResources: { uSampler: texture },\n    };\n\n    const submit: Submit = {\n        commandEncoders: [{\n            passEncoders: [\n                // 绘制\n                {\n                    descriptor: {\n                        colorAttachments: [{ clearValue: [0.5, 0.5, 0.5, 1.0], loadOp: 'clear' }],\n                        depthStencilAttachment: { depthClearValue: 1.0, depthLoadOp: 'clear' },\n                    },\n                    renderPassObjects: [renderObject],\n                },\n                // 从画布中拷贝到纹理。\n                {\n                    __type__: 'CopyTextureToTexture',\n                    source: { texture: null }, // 当值设置为 null或者undefined时表示当前画布。\n                    destination: { texture: texture.texture },\n                    copySize: [canvas.width, canvas.height],\n                },\n            ],\n        }],\n    };\n\n    let then = 0;\n\n    // Draw the scene repeatedly\n    function render()\n    {\n        let now = Date.now();\n\n        now *= 0.001; // convert to seconds\n        const deltaTime = now - then;\n\n        then = now;\n\n        const { projectionMatrix, modelViewMatrix } = drawScene(canvas, deltaTime);\n\n        reactive(renderObject.bindingResources).uProjectionMatrix = { value: projectionMatrix as Float32Array };\n        reactive(renderObject.bindingResources).uModelViewMatrix = { value: modelViewMatrix as Float32Array };\n\n        webgl.submit(submit);\n\n        requestAnimationFrame(render);\n    }\n    requestAnimationFrame(render);\n}\n\n//\n// initBuffers\n//\n// Initialize the buffers we'll need. For this demo, we just\n// have one object -- a simple three-dimensional cube.\n//\nfunction initBuffers()\n{\n    // Now create an array of positions for the cube.\n\n    const positions = [\n        // Front face\n        -1.0, -1.0, 1.0,\n        1.0, -1.0, 1.0,\n        1.0, 1.0, 1.0,\n        -1.0, 1.0, 1.0,\n\n        // Back face\n        -1.0, -1.0, -1.0,\n        -1.0, 1.0, -1.0,\n        1.0, 1.0, -1.0,\n        1.0, -1.0, -1.0,\n\n        // Top face\n        -1.0, 1.0, -1.0,\n        -1.0, 1.0, 1.0,\n        1.0, 1.0, 1.0,\n        1.0, 1.0, -1.0,\n\n        // Bottom face\n        -1.0, -1.0, -1.0,\n        1.0, -1.0, -1.0,\n        1.0, -1.0, 1.0,\n        -1.0, -1.0, 1.0,\n\n        // Right face\n        1.0, -1.0, -1.0,\n        1.0, 1.0, -1.0,\n        1.0, 1.0, 1.0,\n        1.0, -1.0, 1.0,\n\n        // Left face\n        -1.0, -1.0, -1.0,\n        -1.0, -1.0, 1.0,\n        -1.0, 1.0, 1.0,\n        -1.0, 1.0, -1.0,\n    ];\n\n    // Now set up the texture coordinates for the faces.\n\n    const textureCoordinates = [\n        // Front\n        0.0, 0.0,\n        1.0, 0.0,\n        1.0, 1.0,\n        0.0, 1.0,\n        // Back\n        0.0, 0.0,\n        1.0, 0.0,\n        1.0, 1.0,\n        0.0, 1.0,\n        // Top\n        0.0, 0.0,\n        1.0, 0.0,\n        1.0, 1.0,\n        0.0, 1.0,\n        // Bottom\n        0.0, 0.0,\n        1.0, 0.0,\n        1.0, 1.0,\n        0.0, 1.0,\n        // Right\n        0.0, 0.0,\n        1.0, 0.0,\n        1.0, 1.0,\n        0.0, 1.0,\n        // Left\n        0.0, 0.0,\n        1.0, 0.0,\n        1.0, 1.0,\n        0.0, 1.0,\n    ];\n\n    // This array defines each face as two triangles, using the\n    // indices into the vertex array to specify each triangle's\n    // position.\n\n    const indices = [\n        0, 1, 2, 0, 2, 3, // front\n        4, 5, 6, 4, 6, 7, // back\n        8, 9, 10, 8, 10, 11, // top\n        12, 13, 14, 12, 14, 15, // bottom\n        16, 17, 18, 16, 18, 19, // right\n        20, 21, 22, 20, 22, 23, // left\n    ];\n\n    return {\n        position: new Float32Array(positions),\n        textureCoord: new Float32Array(textureCoordinates),\n        indices: new Uint16Array(indices),\n    };\n}\n\n//\n// Draw the scene.\n//\nfunction drawScene(canvas: HTMLCanvasElement, deltaTime: number)\n{\n    // Create a perspective matrix, a special matrix that is\n    // used to simulate the distortion of perspective in a camera.\n    // Our field of view is 45 degrees, with a width/height\n    // ratio that matches the display size of the canvas\n    // and we only want to see objects between 0.1 units\n    // and 100 units away from the camera.\n\n    const fieldOfView = 45 * Math.PI / 180; // in radians\n    const aspect = canvas.clientWidth / canvas.clientHeight;\n    const zNear = 0.1;\n    const zFar = 100.0;\n    const projectionMatrix = mat4.create();\n\n    // note: glmatrix.js always has the first argument\n    // as the destination to receive the result.\n    mat4.perspective(projectionMatrix,\n        fieldOfView,\n        aspect,\n        zNear,\n        zFar);\n\n    // Set the drawing position to the \"identity\" point, which is\n    // the center of the scene.\n    const modelViewMatrix = mat4.create();\n\n    // Now move the drawing position a bit to where we want to\n    // start drawing the square.\n\n    mat4.translate(modelViewMatrix, // destination matrix\n        modelViewMatrix, // matrix to translate\n        [-0.0, 0.0, -6.0]); // amount to translate\n    mat4.rotate(modelViewMatrix, // destination matrix\n        modelViewMatrix, // matrix to rotate\n        cubeRotation, // amount to rotate in radians\n        [0, 0, 1]); // axis to rotate around (Z)\n    mat4.rotate(modelViewMatrix, // destination matrix\n        modelViewMatrix, // matrix to rotate\n        cubeRotation * 0.7, // amount to rotate in radians\n        [0, 1, 0]); // axis to rotate around (X)\n\n    // Update the rotation for the next draw\n\n    cubeRotation += deltaTime;\n\n    return { projectionMatrix, modelViewMatrix };\n}\n"],"names":["cubeRotation","main","canvas","devicePixelRatio","renderingContext","webgl","WebGL","buffers","initBuffers","texture","renderObject","submit","then","render","now","deltaTime","projectionMatrix","modelViewMatrix","drawScene","reactive","positions","textureCoordinates","indices","fieldOfView","aspect","zNear","zFar","mat4.create","mat4.perspective","mat4.translate","mat4.rotate"],"mappings":"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"}