{"version":3,"file":"index-ac627bb5.js","sources":["../../node_modules/@feng3d/reactivity/dist/index.js"],"sourcesContent":["class Reactivity {\n  constructor() {\n    this._parents = /* @__PURE__ */ new Map();\n  }\n  /**\n   * 获取当前节点值。\n   *\n   * 取值时将会建立与父节点的依赖关系。\n   */\n  get value() {\n    this.track();\n    return this._value;\n  }\n  /**\n   * 捕捉。\n   *\n   * 建立与父节点的依赖关系。\n   */\n  track() {\n    if (!Reactivity.activeReactivity || !_shouldTrack)\n      return;\n    const parent = Reactivity.activeReactivity;\n    if (parent) {\n      this._parents.set(parent, parent._version);\n    }\n  }\n  /**\n   * 触发。\n   *\n   * 冒泡到所有父节点，设置失效子节点字典。\n   */\n  trigger() {\n    this._parents.forEach((version, parent) => {\n      if (parent._version !== version)\n        return;\n      parent.trigger();\n      parent._children.set(this, this._value);\n    });\n    this._parents.clear();\n  }\n}\nfunction forceTrack(fn) {\n  const preShouldTrack = _shouldTrack;\n  _shouldTrack = true;\n  const result = fn();\n  _shouldTrack = preShouldTrack;\n  return result;\n}\nfunction noTrack(fn) {\n  const preShouldTrack = _shouldTrack;\n  _shouldTrack = false;\n  const result = fn();\n  _shouldTrack = preShouldTrack;\n  return result;\n}\nlet _shouldTrack = true;\nfunction batch(dep, isRunning) {\n  if (isRunning) {\n    _isRunedDeps.push(dep);\n  } else {\n    _needEffectDeps.push(dep);\n  }\n}\nfunction batchRun(fn) {\n  _batchDepth++;\n  const result = fn();\n  if (--_batchDepth > 0) {\n    return;\n  }\n  if (_isRunedDeps.length > 0) {\n    _isRunedDeps.forEach((dep) => {\n      dep._children.forEach((version, node) => {\n        node._parents.set(dep, dep._version);\n      });\n      dep._children.clear();\n    });\n    _isRunedDeps.length = 0;\n  }\n  if (_needEffectDeps.length > 0) {\n    _needEffectDeps.forEach((dep) => {\n      const pre = Reactivity.activeReactivity;\n      Reactivity.activeReactivity = null;\n      dep.runIfDirty();\n      Reactivity.activeReactivity = pre;\n    });\n    _needEffectDeps.length = 0;\n  }\n  return result;\n}\nlet _batchDepth = 0;\nconst _needEffectDeps = [];\nconst _isRunedDeps = [];\nfunction computed(func) {\n  return new ComputedReactivity(func);\n}\nclass ComputedReactivity extends Reactivity {\n  /**\n   * 创建计算依赖。\n   * @param func 检测的可能包含响应式的函数。\n   */\n  constructor(func) {\n    super();\n    this.__v_isRef = true;\n    this._children = /* @__PURE__ */ new Map();\n    this._isDirty = true;\n    this._version = -1;\n    this._func = func;\n  }\n  /**\n   * 获取值。\n   *\n   * 取值时将会建立与父节点的依赖关系。\n   *\n   * 同时会检查子节点是否发生变化，如果发生变化，则重新计算。\n   */\n  get value() {\n    this.runIfDirty();\n    this.track();\n    return this._value;\n  }\n  /**\n   * 触发。\n   *\n   * 冒泡到所有父节点，设置失效子节点字典。\n   *\n   * 把触发节点添加到失效子节点字典队列中。\n   */\n  trigger() {\n    if (Reactivity.activeReactivity === this) {\n      batch(this, Reactivity.activeReactivity === this);\n    }\n    super.trigger();\n  }\n  /**\n   * 执行当前节点。\n   */\n  run() {\n    forceTrack(() => {\n      const parentReactiveNode = Reactivity.activeReactivity;\n      Reactivity.activeReactivity = this;\n      this._version++;\n      this._value = this._func(this._value);\n      Reactivity.activeReactivity = parentReactiveNode;\n    });\n  }\n  /**\n   * 检查当前节点是否脏。\n   *\n   * 如果脏，则执行计算。\n   */\n  runIfDirty() {\n    this._isDirty = this._isDirty || this.isChildrenChanged();\n    if (this._isDirty) {\n      this._isDirty = false;\n      this.run();\n    }\n  }\n  /**\n   * 判断子节点是否发生变化。\n   */\n  isChildrenChanged() {\n    if (this._children.size === 0)\n      return false;\n    let isChanged = false;\n    const preReactiveNode = Reactivity.activeReactivity;\n    Reactivity.activeReactivity = null;\n    this._children.forEach((value, node) => {\n      if (isChanged)\n        return;\n      if (node.value !== value) {\n        isChanged = true;\n        return;\n      }\n    });\n    Reactivity.activeReactivity = preReactiveNode;\n    if (!isChanged) {\n      this._children.forEach((version, node) => {\n        node._parents.set(this, this._version);\n      });\n    }\n    this._children.clear();\n    return isChanged;\n  }\n}\nfunction effect(fn) {\n  return new EffectReactivity(fn);\n}\nconst _EffectReactivity = class _EffectReactivity2 extends ComputedReactivity {\n  constructor(func) {\n    super(func);\n    this._isEnable = true;\n    this.runIfDirty();\n  }\n  pause() {\n    this._isEnable = false;\n  }\n  resume() {\n    if (this._isEnable)\n      return;\n    this._isEnable = true;\n    if (_EffectReactivity2.pausedQueueEffects.has(this)) {\n      _EffectReactivity2.pausedQueueEffects.delete(this);\n      this.trigger();\n    }\n  }\n  trigger() {\n    batchRun(() => {\n      super.trigger();\n      if (this._isEnable) {\n        batch(this, Reactivity.activeReactivity === this);\n      } else {\n        _EffectReactivity2.pausedQueueEffects.add(this);\n      }\n    });\n  }\n  /**\n   * 执行当前节点。\n   *\n   * 当暂停时将会直接执行被包装的函数。\n   */\n  run() {\n    if (this._isEnable) {\n      super.run();\n    } else {\n      this._func(this._value);\n    }\n  }\n};\n_EffectReactivity.pausedQueueEffects = /* @__PURE__ */ new WeakSet();\nlet EffectReactivity = _EffectReactivity;\nvar ReactiveFlags = /* @__PURE__ */ ((ReactiveFlags2) => {\n  ReactiveFlags2[\"IS_REACTIVE\"] = \"__v_isReactive\";\n  ReactiveFlags2[\"RAW\"] = \"__v_raw\";\n  ReactiveFlags2[\"IS_REF\"] = \"__v_isRef\";\n  return ReactiveFlags2;\n})(ReactiveFlags || {});\nvar TargetType = /* @__PURE__ */ ((TargetType2) => {\n  TargetType2[TargetType2[\"INVALID\"] = 0] = \"INVALID\";\n  TargetType2[TargetType2[\"COMMON\"] = 1] = \"COMMON\";\n  TargetType2[TargetType2[\"COLLECTION\"] = 2] = \"COLLECTION\";\n  return TargetType2;\n})(TargetType || {});\nvar TrackOpTypes = /* @__PURE__ */ ((TrackOpTypes2) => {\n  TrackOpTypes2[\"GET\"] = \"get\";\n  TrackOpTypes2[\"HAS\"] = \"has\";\n  TrackOpTypes2[\"ITERATE\"] = \"iterate\";\n  return TrackOpTypes2;\n})(TrackOpTypes || {});\nvar TriggerOpTypes = /* @__PURE__ */ ((TriggerOpTypes2) => {\n  TriggerOpTypes2[\"SET\"] = \"set\";\n  TriggerOpTypes2[\"ADD\"] = \"add\";\n  TriggerOpTypes2[\"DELETE\"] = \"delete\";\n  TriggerOpTypes2[\"CLEAR\"] = \"clear\";\n  return TriggerOpTypes2;\n})(TriggerOpTypes || {});\nconst ITERATE_KEY = Symbol(\"\");\nconst MAP_KEY_ITERATE_KEY = Symbol(\"\");\nconst ARRAY_ITERATE_KEY = Symbol(\"\");\nglobalThis.__DEV__ ?? (globalThis.__DEV__ = true);\nconst isObject = (val) => val !== null && typeof val === \"object\";\nconst isArray = Array.isArray;\nconst isSymbol = (val) => typeof val === \"symbol\";\nconst isString = (val) => typeof val === \"string\";\nconst isIntegerKey = (key) => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && `${parseInt(key, 10)}` === key;\nconst isMap = (val) => toTypeString(val) === \"[object Map]\";\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return TargetType.COMMON;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return TargetType.COLLECTION;\n    default:\n      return TargetType.COMMON;\n  }\n}\nfunction getTargetType(value) {\n  if (!Object.isExtensible(value))\n    return TargetType.INVALID;\n  return targetTypeMap(toRawType(value));\n}\nconst toTypeString = (value) => Object.prototype.toString.call(value);\nconst toRawType = (value) => (\n  // 从类似 \"[object RawType]\" 的字符串中提取 \"RawType\"\n  toTypeString(value).slice(8, -1)\n);\nfunction toRaw(observed) {\n  const raw = observed && observed[ReactiveFlags.RAW];\n  return raw ? toRaw(raw) : observed;\n}\n// @__NO_SIDE_EFFECTS__\nfunction makeMap(str) {\n  const map = /* @__PURE__ */ Object.create(null);\n  for (const key of str.split(\",\"))\n    map[key] = 1;\n  return (val) => val in map;\n}\nfunction property(target, key) {\n  let depsMap = PropertyReactivity._targetMap.get(target);\n  if (!depsMap) {\n    depsMap = /* @__PURE__ */ new Map();\n    PropertyReactivity._targetMap.set(target, depsMap);\n  }\n  let dep = depsMap.get(key);\n  if (!dep) {\n    dep = new PropertyReactivity(target, key);\n    depsMap.set(key, dep);\n  }\n  return dep;\n}\nclass PropertyReactivity extends Reactivity {\n  constructor(target, key) {\n    super();\n    this._target = target;\n    this._key = key;\n    if (target instanceof Map || target instanceof WeakMap) {\n      this._value = target.get(key);\n    } else if (target instanceof Set || target instanceof WeakSet) {\n      this._value = target.has(key);\n    } else {\n      this._value = target[key];\n    }\n  }\n  /**\n   * 获取当前节点值。\n   *\n   * 取值时将会建立与父节点的依赖关系。\n   */\n  get value() {\n    this.track();\n    return this._value;\n  }\n  set value(v) {\n    if (this._key === \"length\") {\n      v = this._target[\"length\"];\n    } else if (isSymbol(this._key)) {\n      v = ~~this._value + 1;\n    }\n    if (v === this._value)\n      return;\n    this.trigger();\n    this._value = v;\n  }\n  triggerIfChanged() {\n  }\n  /**\n   * 追踪属性的变化。\n   *\n   * 当属性被访问时，将会追踪属性的变化。\n   *\n   * @param target 目标对象。\n   * @param key  属性名。\n   * @returns\n   */\n  static track(target, type, key) {\n    if (!Reactivity.activeReactivity)\n      return;\n    const dep = property(target, key);\n    dep.track();\n  }\n  /**\n   * 触发属性的变化。\n   *\n   * @param target 目标对象。\n   * @param type    操作类型。\n   * @param key 属性名。\n   * @param newValue 新值。\n   * @param oldValue 旧值。\n   * @returns\n   */\n  static trigger(target, type, key, newValue, oldValue) {\n    const depsMap = this._targetMap.get(target);\n    if (!depsMap)\n      return;\n    const run = (dep) => {\n      if (dep) {\n        dep.value = newValue;\n      }\n    };\n    batchRun(() => {\n      if (type === TriggerOpTypes.CLEAR) {\n        depsMap.forEach(run);\n      } else {\n        const targetIsArray = isArray(target);\n        const isArrayIndex = targetIsArray && isIntegerKey(key);\n        if (targetIsArray && key === \"length\") {\n          const newLength = Number(newValue);\n          depsMap.forEach((dep, key2) => {\n            if (key2 === \"length\" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {\n              run(dep);\n            }\n          });\n        } else {\n          if (key !== void 0 || depsMap.has(void 0)) {\n            run(depsMap.get(key));\n          }\n          if (isArrayIndex) {\n            run(depsMap.get(ARRAY_ITERATE_KEY));\n          }\n          switch (type) {\n            case TriggerOpTypes.ADD:\n              if (!targetIsArray) {\n                run(depsMap.get(ITERATE_KEY));\n                if (isMap(target)) {\n                  run(depsMap.get(MAP_KEY_ITERATE_KEY));\n                }\n              } else if (isArrayIndex) {\n                run(depsMap.get(\"length\"));\n              }\n              break;\n            case TriggerOpTypes.DELETE:\n              if (!targetIsArray) {\n                run(depsMap.get(ITERATE_KEY));\n                if (isMap(target)) {\n                  run(depsMap.get(MAP_KEY_ITERATE_KEY));\n                }\n              }\n              break;\n            case TriggerOpTypes.SET:\n              if (isMap(target)) {\n                run(depsMap.get(ITERATE_KEY));\n              }\n              break;\n          }\n        }\n      }\n    });\n  }\n}\nPropertyReactivity._targetMap = /* @__PURE__ */ new WeakMap();\nconst arrayInstrumentations = {\n  __proto__: null,\n  /**\n   * 返回一个迭代器，用于遍历数组的响应式值\n   */\n  [Symbol.iterator]() {\n    return iterator(this, Symbol.iterator, toReactive);\n  },\n  /**\n   * 连接数组并返回新数组，处理响应式数组\n   */\n  concat(...args) {\n    return reactiveReadArray(this).concat(\n      ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)\n    );\n  },\n  /**\n   * 返回一个迭代器，用于遍历数组的键值对，并将值转换为响应式\n   */\n  entries() {\n    return iterator(this, \"entries\", (value) => {\n      value[1] = toReactive(value[1]);\n      return value;\n    });\n  },\n  /**\n   * 测试数组中的所有元素是否都通过了指定函数的测试\n   */\n  every(fn, thisArg) {\n    return apply(this, \"every\", fn, thisArg, void 0, arguments);\n  },\n  /**\n   * 创建一个新数组，包含通过指定函数测试的所有元素\n   */\n  filter(fn, thisArg) {\n    return apply(this, \"filter\", fn, thisArg, (v) => v.map(toReactive), arguments);\n  },\n  /**\n   * 返回数组中满足指定测试函数的第一个元素\n   */\n  find(fn, thisArg) {\n    return apply(this, \"find\", fn, thisArg, toReactive, arguments);\n  },\n  /**\n   * 返回数组中满足指定测试函数的第一个元素的索引\n   */\n  findIndex(fn, thisArg) {\n    return apply(this, \"findIndex\", fn, thisArg, void 0, arguments);\n  },\n  /**\n   * 返回数组中满足指定测试函数的最后一个元素\n   */\n  findLast(fn, thisArg) {\n    return apply(this, \"findLast\", fn, thisArg, toReactive, arguments);\n  },\n  /**\n   * 返回数组中满足指定测试函数的最后一个元素的索引\n   */\n  findLastIndex(fn, thisArg) {\n    return apply(this, \"findLastIndex\", fn, thisArg, void 0, arguments);\n  },\n  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement\n  /**\n   * 对数组中的每个元素执行指定函数\n   */\n  forEach(fn, thisArg) {\n    return apply(this, \"forEach\", fn, thisArg, void 0, arguments);\n  },\n  /**\n   * 判断数组是否包含指定元素，处理响应式值\n   */\n  includes(...args) {\n    return searchProxy(this, \"includes\", args);\n  },\n  /**\n   * 返回数组中指定元素第一次出现的索引，处理响应式值\n   */\n  indexOf(...args) {\n    return searchProxy(this, \"indexOf\", args);\n  },\n  /**\n   * 将数组的所有元素连接成一个字符串\n   */\n  join(separator) {\n    return reactiveReadArray(this).join(separator);\n  },\n  // keys() iterator only reads `length`, no optimisation required\n  /**\n   * 返回数组中指定元素最后一次出现的索引，处理响应式值\n   */\n  lastIndexOf(...args) {\n    return searchProxy(this, \"lastIndexOf\", args);\n  },\n  /**\n   * 创建一个新数组，包含对原数组每个元素调用指定函数的结果\n   */\n  map(fn, thisArg) {\n    return apply(this, \"map\", fn, thisArg, void 0, arguments);\n  },\n  /**\n   * 移除数组的最后一个元素并返回该元素，避免跟踪长度变化\n   */\n  pop() {\n    return noTracking(this, \"pop\");\n  },\n  /**\n   * 向数组末尾添加一个或多个元素，并返回新的长度，避免跟踪长度变化\n   */\n  push(...args) {\n    return noTracking(this, \"push\", args);\n  },\n  /**\n   * 对数组中的每个元素执行累加器函数，并返回最终结果\n   */\n  reduce(fn, ...args) {\n    return reduce(this, \"reduce\", fn, args);\n  },\n  /**\n   * 从右到左对数组中的每个元素执行累加器函数，并返回最终结果\n   */\n  reduceRight(fn, ...args) {\n    return reduce(this, \"reduceRight\", fn, args);\n  },\n  /**\n   * 移除数组的第一个元素并返回该元素，避免跟踪长度变化\n   */\n  shift() {\n    return noTracking(this, \"shift\");\n  },\n  // slice could use ARRAY_ITERATE but also seems to beg for range tracking\n  /**\n   * 测试数组中的某些元素是否通过了指定函数的测试\n   */\n  some(fn, thisArg) {\n    return apply(this, \"some\", fn, thisArg, void 0, arguments);\n  },\n  /**\n   * 通过删除或替换现有元素或添加新元素来修改数组，避免跟踪长度变化\n   */\n  splice(...args) {\n    return noTracking(this, \"splice\", args);\n  },\n  /**\n   * 返回一个新数组，包含原数组的反转副本\n   */\n  toReversed() {\n    return reactiveReadArray(this).toReversed();\n  },\n  /**\n   * 返回一个新数组，包含原数组的排序副本\n   */\n  toSorted(comparer) {\n    return reactiveReadArray(this).toSorted(comparer);\n  },\n  /**\n   * 返回一个新数组，包含原数组的切片副本\n   */\n  toSpliced(...args) {\n    return reactiveReadArray(this).toSpliced(...args);\n  },\n  /**\n   * 向数组开头添加一个或多个元素，并返回新的长度，避免跟踪长度变化\n   */\n  unshift(...args) {\n    return noTracking(this, \"unshift\", args);\n  },\n  /**\n   * 返回一个迭代器，用于遍历数组的响应式值\n   */\n  values() {\n    return iterator(this, \"values\", toReactive);\n  }\n};\nfunction iterator(self, method, wrapValue) {\n  const arr = shallowReadArray(self);\n  const iter = arr[method]();\n  if (arr !== self) {\n    iter._next = iter.next;\n    iter.next = () => {\n      const result = iter._next();\n      if (result.value) {\n        result.value = wrapValue(result.value);\n      }\n      return result;\n    };\n  }\n  return iter;\n}\nfunction shallowReadArray(arr) {\n  PropertyReactivity.track(arr = toRaw(arr), TrackOpTypes.ITERATE, ARRAY_ITERATE_KEY);\n  return arr;\n}\nfunction reactiveReadArray(array) {\n  const raw = toRaw(array);\n  if (raw === array)\n    return raw;\n  PropertyReactivity.track(raw, TrackOpTypes.ITERATE, ARRAY_ITERATE_KEY);\n  return raw.map(toReactive);\n}\nfunction apply(self, method, fn, thisArg, wrappedRetFn, args) {\n  const arr = shallowReadArray(self);\n  const needsWrap = arr !== self;\n  const methodFn = arr[method];\n  if (methodFn !== Array.prototype[method]) {\n    const result2 = methodFn.apply(self, args);\n    return needsWrap ? toReactive(result2) : result2;\n  }\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (needsWrap) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, toReactive(item), index, self);\n      };\n    } else if (fn.length > 2) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, item, index, self);\n      };\n    }\n  }\n  const result = methodFn.call(arr, wrappedFn, thisArg);\n  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;\n}\nfunction reduce(self, method, fn, args) {\n  const arr = shallowReadArray(self);\n  let wrappedFn = fn;\n  if (arr !== self) {\n    wrappedFn = function(acc, item, index) {\n      return fn.call(this, acc, toReactive(item), index, self);\n    };\n  }\n  return arr[method](wrappedFn, ...args);\n}\nfunction searchProxy(self, method, args) {\n  const arr = toRaw(self);\n  PropertyReactivity.track(arr, TrackOpTypes.ITERATE, ARRAY_ITERATE_KEY);\n  const res = arr[method](...args);\n  if ((res === -1 || res === false) && isProxy(args[0])) {\n    args[0] = toRaw(args[0]);\n    return arr[method](...args);\n  }\n  return res;\n}\nfunction noTracking(self, method, args = []) {\n  const res = batchRun(\n    () => noTrack(\n      () => toRaw(self)[method].apply(self, args)\n    )\n  );\n  return res;\n}\nvar _a;\nfunction ref(value) {\n  if (isRef(value)) {\n    return value;\n  }\n  return new RefReactivity(value);\n}\nfunction isRef(r) {\n  return r ? r[ReactiveFlags.IS_REF] === true : false;\n}\nclass RefReactivity extends Reactivity {\n  constructor(value) {\n    super();\n    this[_a] = true;\n    this._rawValue = toRaw(value);\n    this._value = toReactive(value);\n  }\n  get value() {\n    this.track();\n    return this._value;\n  }\n  set value(v) {\n    const oldValue = this._rawValue;\n    const newValue = toRaw(v);\n    if (!hasChanged(oldValue, newValue))\n      return;\n    batchRun(() => {\n      this.trigger();\n      this._rawValue = newValue;\n      this._value = toReactive(newValue);\n    });\n  }\n}\n_a = ReactiveFlags.IS_REF;\nclass BaseReactiveHandler {\n  /**\n   * 获取对象的属性值。\n   *\n   * @param target 对象本身\n   * @param key 属性名\n   * @param receiver 代理对象\n   * @returns\n   */\n  get(target, key, receiver) {\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return true;\n    } else if (key === ReactiveFlags.RAW) {\n      if (receiver === reactiveMap.get(target) || Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {\n        return target;\n      }\n      return;\n    }\n    const targetIsArray = isArray(target);\n    let fn;\n    if (targetIsArray && (fn = arrayInstrumentations[key])) {\n      return fn;\n    }\n    if (key === \"hasOwnProperty\") {\n      return hasOwnProperty;\n    }\n    const res = Reflect.get(\n      target,\n      key,\n      isRef(target) ? target : receiver\n    );\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    PropertyReactivity.track(target, TrackOpTypes.GET, key);\n    if (isRef(res)) {\n      return targetIsArray && isIntegerKey(key) ? res : res.value;\n    }\n    if (isObject(res)) {\n      return reactive(res);\n    }\n    return res;\n  }\n}\nclass MutableReactiveHandler extends BaseReactiveHandler {\n  /**\n   * 设置对象的属性值。\n   * @param target 被代理的对象。\n   * @param key 属性名。\n   * @param value 新值。\n   * @param receiver 代理对象。\n   * @returns 设置是否成功。\n   */\n  set(target, key, value, receiver) {\n    let oldValue = target[key];\n    oldValue = toRaw(oldValue);\n    value = toRaw(value);\n    if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    }\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(\n      target,\n      key,\n      value,\n      isRef(target) ? target : receiver\n    );\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        PropertyReactivity.trigger(target, TriggerOpTypes.ADD, key, value);\n      } else if (hasChanged(value, oldValue)) {\n        PropertyReactivity.trigger(target, TriggerOpTypes.SET, key, value, oldValue);\n      }\n    }\n    return result;\n  }\n  /**\n   * 删除对象的属性。\n   *\n   * @param target 被代理的对象。\n   * @param key 属性名。\n   * @returns 删除是否成功。\n   */\n  deleteProperty(target, key) {\n    const hadKey = hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n      PropertyReactivity.trigger(target, TriggerOpTypes.DELETE, key, void 0, oldValue);\n    }\n    return result;\n  }\n  has(target, key) {\n    const result = Reflect.has(target, key);\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\n      PropertyReactivity.track(target, TrackOpTypes.HAS, key);\n    }\n    return result;\n  }\n  ownKeys(target) {\n    PropertyReactivity.track(\n      target,\n      TrackOpTypes.ITERATE,\n      isArray(target) ? \"length\" : ITERATE_KEY\n    );\n    return Reflect.ownKeys(target);\n  }\n}\nconst mutableHandlers = new MutableReactiveHandler();\nfunction hasOwnProperty(key) {\n  if (!isSymbol(key))\n    key = String(key);\n  const obj = toRaw(this);\n  PropertyReactivity.track(obj, TrackOpTypes.HAS, key);\n  return obj.hasOwnProperty(key);\n}\nconst builtInSymbols = new Set(\n  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== \"arguments\" && key !== \"caller\").map((key) => Symbol[key]).filter(isSymbol)\n);\nconst isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);\nconst mutableCollectionHandlers = {\n  get: createInstrumentationGetter()\n};\nfunction createInstrumentationGetter() {\n  const instrumentations = createInstrumentations();\n  return (target, key, receiver) => {\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return true;\n    } else if (key === ReactiveFlags.RAW) {\n      return target;\n    }\n    return Reflect.get(\n      hasOwn(instrumentations, key) && key in target ? instrumentations : target,\n      key,\n      receiver\n    );\n  };\n}\nfunction createInstrumentations() {\n  const instrumentations = {\n    get(key) {\n      const target = this[ReactiveFlags.RAW];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (hasChanged(key, rawKey)) {\n        PropertyReactivity.track(rawTarget, TrackOpTypes.GET, key);\n      }\n      PropertyReactivity.track(rawTarget, TrackOpTypes.GET, rawKey);\n      const { has } = getProto(rawTarget);\n      const wrap = toReactive;\n      if (has.call(rawTarget, key)) {\n        return wrap(target.get(key));\n      } else if (has.call(rawTarget, rawKey)) {\n        return wrap(target.get(rawKey));\n      } else if (target !== rawTarget) {\n        target.get(key);\n      }\n    },\n    get size() {\n      const target = this[ReactiveFlags.RAW];\n      PropertyReactivity.track(toRaw(target), TrackOpTypes.ITERATE, ITERATE_KEY);\n      return Reflect.get(target, \"size\", target);\n    },\n    has(key) {\n      const target = this[ReactiveFlags.RAW];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (hasChanged(key, rawKey)) {\n        PropertyReactivity.track(rawTarget, TrackOpTypes.HAS, key);\n      }\n      PropertyReactivity.track(rawTarget, TrackOpTypes.HAS, rawKey);\n      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n    },\n    forEach(callback, thisArg) {\n      const observed = this;\n      const target = observed[ReactiveFlags.RAW];\n      const rawTarget = toRaw(target);\n      const wrap = toReactive;\n      PropertyReactivity.track(rawTarget, TrackOpTypes.ITERATE, ITERATE_KEY);\n      return target.forEach(\n        (value, key) => (\n          // important: make sure the callback is\n          // 1. invoked with the reactive map as `this` and 3rd arg\n          // 2. the value received should be a corresponding reactive/readonly.\n          callback.call(thisArg, wrap(value), wrap(key), observed)\n        )\n      );\n    },\n    add(value) {\n      value = toRaw(value);\n      const target = toRaw(this);\n      const proto = getProto(target);\n      const hadKey = proto.has.call(target, value);\n      if (!hadKey) {\n        target.add(value);\n        PropertyReactivity.trigger(target, TriggerOpTypes.ADD, value, value);\n      }\n      return this;\n    },\n    set(key, value) {\n      value = toRaw(value);\n      const target = toRaw(this);\n      const { has, get } = getProto(target);\n      let hadKey = has.call(target, key);\n      if (!hadKey) {\n        key = toRaw(key);\n        hadKey = has.call(target, key);\n      }\n      const oldValue = get.call(target, key);\n      target.set(key, value);\n      if (!hadKey) {\n        PropertyReactivity.trigger(target, TriggerOpTypes.ADD, key, value);\n      } else if (hasChanged(value, oldValue)) {\n        PropertyReactivity.trigger(target, TriggerOpTypes.SET, key, value, oldValue);\n      }\n      return this;\n    },\n    delete(key) {\n      const target = toRaw(this);\n      const { has, get } = getProto(target);\n      let hadKey = has.call(target, key);\n      if (!hadKey) {\n        key = toRaw(key);\n        hadKey = has.call(target, key);\n      }\n      const oldValue = get ? get.call(target, key) : void 0;\n      const result = target.delete(key);\n      if (hadKey) {\n        PropertyReactivity.trigger(target, TriggerOpTypes.DELETE, key, void 0, oldValue);\n      }\n      return result;\n    },\n    clear() {\n      const target = toRaw(this);\n      const hadItems = target.size !== 0;\n      const oldTarget = void 0;\n      const result = target.clear();\n      if (hadItems) {\n        PropertyReactivity.trigger(\n          target,\n          TriggerOpTypes.CLEAR,\n          void 0,\n          void 0,\n          oldTarget\n        );\n      }\n      return result;\n    }\n  };\n  const iteratorMethods = [\n    \"keys\",\n    \"values\",\n    \"entries\",\n    Symbol.iterator\n  ];\n  iteratorMethods.forEach((method) => {\n    instrumentations[method] = createIterableMethod(method);\n  });\n  return instrumentations;\n}\nfunction createIterableMethod(method) {\n  return function(...args) {\n    const target = this[ReactiveFlags.RAW];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = toReactive;\n    PropertyReactivity.track(\n      rawTarget,\n      TrackOpTypes.ITERATE,\n      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n    );\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next();\n        return done ? { value, done } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction reactive(target) {\n  if (!isObject(target)) {\n    return target;\n  }\n  if (target[ReactiveFlags.RAW]) {\n    return target;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === TargetType.INVALID) {\n    return target;\n  }\n  const existingProxy = reactiveMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === TargetType.COLLECTION ? mutableCollectionHandlers : mutableHandlers\n  );\n  reactiveMap.set(target, proxy);\n  return proxy;\n}\nconst reactiveMap = /* @__PURE__ */ new WeakMap();\nfunction isReactive(value) {\n  return !!(value && value[ReactiveFlags.IS_REACTIVE]);\n}\nconst toReactive = (value) => {\n  if (isObject(value)) {\n    return reactive(value);\n  }\n  return value;\n};\nfunction isProxy(value) {\n  return value ? !!value[ReactiveFlags.RAW] : false;\n}\nexport {\n  ComputedReactivity as ComputedDep,\n  Reactivity as Dep,\n  EffectReactivity as EffectDep,\n  RefReactivity,\n  batchRun,\n  computed,\n  effect,\n  forceTrack,\n  isProxy,\n  isReactive,\n  isRef,\n  noTrack,\n  reactive,\n  ref,\n  toRaw\n};\n//# sourceMappingURL=index.js.map\n"],"names":["Reactivity","_shouldTrack","parent","version","forceTrack","fn","preShouldTrack","result","noTrack","batch","dep","isRunning","_isRunedDeps","_needEffectDeps","batchRun","_batchDepth","node","pre","ComputedReactivity","func","parentReactiveNode","isChanged","preReactiveNode","value","effect","EffectReactivity","_EffectReactivity","_EffectReactivity2","ReactiveFlags","ReactiveFlags2","TargetType","TargetType2","TrackOpTypes","TrackOpTypes2","TriggerOpTypes","TriggerOpTypes2","ITERATE_KEY","MAP_KEY_ITERATE_KEY","ARRAY_ITERATE_KEY","isObject","val","isArray","isSymbol","isString","isIntegerKey","key","isMap","toTypeString","hasOwn","hasChanged","oldValue","targetTypeMap","rawType","getTargetType","toRawType","toRaw","observed","raw","makeMap","str","map","property","target","depsMap","PropertyReactivity","v","type","newValue","run","targetIsArray","isArrayIndex","newLength","key2","arrayInstrumentations","iterator","toReactive","args","reactiveReadArray","x","thisArg","apply","searchProxy","separator","noTracking","reduce","comparer","self","method","wrapValue","arr","shallowReadArray","iter","array","wrappedRetFn","needsWrap","methodFn","result2","wrappedFn","item","index","acc","res","isProxy","isRef","r","BaseReactiveHandler","receiver","reactiveMap","hasOwnProperty","builtInSymbols","isNonTrackableKeys","reactive","MutableReactiveHandler","hadKey","mutableHandlers","obj","mutableCollectionHandlers","createInstrumentationGetter","instrumentations","createInstrumentations","rawTarget","rawKey","has","getProto","wrap","callback","get","hadItems","oldTarget","createIterableMethod","targetIsMap","isPair","isKeyOnly","innerIterator","done","targetType","existingProxy","proxy"],"mappings":"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","x_google_ignoreList":[0]}