{"version":3,"file":"gltf-loader-CDzcHVJC.js","sources":["../../node_modules/gl-matrix/esm/mat3.js","../../node_modules/gl-matrix/esm/vec4.js","../../node_modules/gl-matrix/esm/quat.js","../../examples/src/WebGL2Samples/third-party/gltf-loader.ts"],"sourcesContent":["import * as glMatrix from \"./common.js\";\n\n/**\n * 3x3 Matrix\n * @module mat3\n */\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {ReadonlyMat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\nexport function fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n\n/**\n * Create a new mat3 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} A new mat3\n */\nexport function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} out\n */\nexport function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n      a02 = a[2],\n      a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n  return out;\n}\n\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3 | null} out, or null if source matrix is not invertible\n */\nexport function invert(out, a) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2];\n  var a10 = a[3],\n    a11 = a[4],\n    a12 = a[5];\n  var a20 = a[6],\n    a21 = a[7],\n    a22 = a[8];\n  var b01 = a22 * a11 - a12 * a21;\n  var b11 = -a22 * a10 + a12 * a20;\n  var b21 = a21 * a10 - a11 * a20;\n\n  // Calculate the determinant\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\nexport function adjoint(out, a) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2];\n  var a10 = a[3],\n    a11 = a[4],\n    a12 = a[5];\n  var a20 = a[6],\n    a21 = a[7],\n    a22 = a[8];\n  out[0] = a11 * a22 - a12 * a21;\n  out[1] = a02 * a21 - a01 * a22;\n  out[2] = a01 * a12 - a02 * a11;\n  out[3] = a12 * a20 - a10 * a22;\n  out[4] = a00 * a22 - a02 * a20;\n  out[5] = a02 * a10 - a00 * a12;\n  out[6] = a10 * a21 - a11 * a20;\n  out[7] = a01 * a20 - a00 * a21;\n  out[8] = a00 * a11 - a01 * a10;\n  return out;\n}\n\n/**\n * Calculates the determinant of a mat3\n *\n * @param {ReadonlyMat3} a the source matrix\n * @returns {Number} determinant of a\n */\nexport function determinant(a) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2];\n  var a10 = a[3],\n    a11 = a[4],\n    a12 = a[5];\n  var a20 = a[6],\n    a21 = a[7],\n    a22 = a[8];\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2];\n  var a10 = a[3],\n    a11 = a[4],\n    a12 = a[5];\n  var a20 = a[6],\n    a21 = a[7],\n    a22 = a[8];\n  var b00 = b[0],\n    b01 = b[1],\n    b02 = b[2];\n  var b10 = b[3],\n    b11 = b[4],\n    b12 = b[5];\n  var b20 = b[6],\n    b21 = b[7],\n    b22 = b[8];\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to translate\n * @param {ReadonlyVec2} v vector to translate by\n * @returns {mat3} out\n */\nexport function translate(out, a, v) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2],\n    a10 = a[3],\n    a11 = a[4],\n    a12 = a[5],\n    a20 = a[6],\n    a21 = a[7],\n    a22 = a[8],\n    x = v[0],\n    y = v[1];\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nexport function rotate(out, a, rad) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2],\n    a10 = a[3],\n    a11 = a[4],\n    a12 = a[5],\n    a20 = a[6],\n    a21 = a[7],\n    a22 = a[8],\n    s = Math.sin(rad),\n    c = Math.cos(rad);\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n}\n\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to scale\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\nexport function scale(out, a, v) {\n  var x = v[0],\n    y = v[1];\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.translate(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Translation vector\n * @returns {mat3} out\n */\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = v[0];\n  out[7] = v[1];\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.rotate(dest, dest, rad);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nexport function fromRotation(out, rad) {\n  var s = Math.sin(rad),\n    c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = -s;\n  out[4] = c;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.scale(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat3} out\n */\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to copy\n * @returns {mat3} out\n **/\nexport function fromMat2d(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = 0;\n  out[3] = a[2];\n  out[4] = a[3];\n  out[5] = 0;\n  out[6] = a[4];\n  out[7] = a[5];\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */\nexport function fromQuat(out, q) {\n  var x = q[0],\n    y = q[1],\n    z = q[2],\n    w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n  return out;\n}\n\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */\nexport function normalFromMat4(out, a) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2],\n    a03 = a[3];\n  var a10 = a[4],\n    a11 = a[5],\n    a12 = a[6],\n    a13 = a[7];\n  var a20 = a[8],\n    a21 = a[9],\n    a22 = a[10],\n    a23 = a[11];\n  var a30 = a[12],\n    a31 = a[13],\n    a32 = a[14],\n    a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32;\n\n  // Calculate the determinant\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return out;\n}\n\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\nexport function projection(out, width, height) {\n  out[0] = 2 / width;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -2 / height;\n  out[5] = 0;\n  out[6] = -1;\n  out[7] = 1;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Returns a string representation of a mat3\n *\n * @param {ReadonlyMat3} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nexport function str(a) {\n  return \"mat3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \")\";\n}\n\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nexport function frob(a) {\n  return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3] + a[4] * a[4] + a[5] * a[5] + a[6] * a[6] + a[7] * a[7] + a[8] * a[8]);\n}\n\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n\n/**\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat3} out the receiving vector\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat3} out\n */\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  return out;\n}\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n}\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nexport function equals(a, b) {\n  var a0 = a[0],\n    a1 = a[1],\n    a2 = a[2],\n    a3 = a[3],\n    a4 = a[4],\n    a5 = a[5],\n    a6 = a[6],\n    a7 = a[7],\n    a8 = a[8];\n  var b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3],\n    b4 = b[4],\n    b5 = b[5],\n    b6 = b[6],\n    b7 = b[7],\n    b8 = b[8];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));\n}\n\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\nexport var mul = multiply;\n\n/**\n * Alias for {@link mat3.subtract}\n * @function\n */\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\n\n/**\n * 4 Dimensional Vector\n * @module vec4\n */\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n  return out;\n}\n\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {ReadonlyVec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\nexport function fromValues(x, y, z, w) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the source vector\n * @returns {vec4} out\n */\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\nexport function set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n\n/**\n * Math.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to ceil\n * @returns {vec4} out\n */\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n\n/**\n * Math.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to floor\n * @returns {vec4} out\n */\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n\n/**\n * symmetric round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to round\n * @returns {vec4} out\n */\nexport function round(out, a) {\n  out[0] = glMatrix.round(a[0]);\n  out[1] = glMatrix.round(a[1]);\n  out[2] = glMatrix.round(a[2]);\n  out[3] = glMatrix.round(a[3]);\n  return out;\n}\n\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} distance between a and b\n */\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.sqrt(x * x + y * y + z * z + w * w);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n\n/**\n * Calculates the length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.sqrt(x * x + y * y + z * z + w * w);\n}\n\n/**\n * Calculates the squared length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to negate\n * @returns {vec4} out\n */\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to invert\n * @returns {vec4} out\n */\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to normalize\n * @returns {vec4} out\n */\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param {ReadonlyVec4} out the receiving vector\n * @param {ReadonlyVec4} u the first vector\n * @param {ReadonlyVec4} v the second vector\n * @param {ReadonlyVec4} w the third vector\n * @returns {vec4} result\n */\nexport function cross(out, u, v, w) {\n  var A = v[0] * w[1] - v[1] * w[0],\n    B = v[0] * w[2] - v[2] * w[0],\n    C = v[0] * w[3] - v[3] * w[0],\n    D = v[1] * w[2] - v[2] * w[1],\n    E = v[1] * w[3] - v[3] * w[1],\n    F = v[2] * w[3] - v[3] * w[2];\n  var G = u[0];\n  var H = u[1];\n  var I = u[2];\n  var J = u[3];\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n  return out;\n}\n\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec4} out\n */\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned\n * @returns {vec4} out\n */\nexport function random(out, scale) {\n  scale = scale === undefined ? 1.0 : scale;\n\n  // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n  var v1, v2, v3, v4;\n  var s1, s2;\n  var rand;\n  rand = glMatrix.RANDOM();\n  v1 = rand * 2 - 1;\n  v2 = (4 * glMatrix.RANDOM() - 2) * Math.sqrt(rand * -rand + rand);\n  s1 = v1 * v1 + v2 * v2;\n  rand = glMatrix.RANDOM();\n  v3 = rand * 2 - 1;\n  v4 = (4 * glMatrix.RANDOM() - 2) * Math.sqrt(rand * -rand + rand);\n  s2 = v3 * v3 + v4 * v4;\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec4} out\n */\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n    y = a[1],\n    z = a[2],\n    w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyQuat} q normalized quaternion to transform with\n * @returns {vec4} out\n */\nexport function transformQuat(out, a, q) {\n  // Fast Vector Rotation using Quaternions by Robert Eisele\n  // https://raw.org/proof/vector-rotation-using-quaternions/\n\n  var qx = q[0],\n    qy = q[1],\n    qz = q[2],\n    qw = q[3];\n  var vx = a[0],\n    vy = a[1],\n    vz = a[2];\n\n  // t = q x v\n  var tx = qy * vz - qz * vy;\n  var ty = qz * vx - qx * vz;\n  var tz = qx * vy - qy * vx;\n\n  // t = 2t\n  tx = tx + tx;\n  ty = ty + ty;\n  tz = tz + tz;\n\n  // v + w t + q x t\n  out[0] = vx + qw * tx + qy * tz - qz * ty;\n  out[1] = vy + qw * ty + qz * tx - qx * tz;\n  out[2] = vz + qw * tz + qx * ty - qy * tx;\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Set the components of a vec4 to zero\n *\n * @param {vec4} out the receiving vector\n * @returns {vec4} out\n */\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec4} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nexport function str(a) {\n  return \"vec4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function equals(a, b) {\n  var a0 = a[0],\n    a1 = a[1],\n    a2 = a[2],\n    a3 = a[3];\n  var b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\nexport var sub = subtract;\n\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\nexport var mul = multiply;\n\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\nexport var div = divide;\n\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\nexport var dist = distance;\n\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\nexport var sqrDist = squaredDistance;\n\n/**\n * Alias for {@link vec4.length}\n * @function\n */\nexport var len = length;\n\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\nexport var sqrLen = squaredLength;\n\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n    if (!stride) {\n      stride = 4;\n    }\n    if (!offset) {\n      offset = 0;\n    }\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n    return a;\n  };\n}();","import * as glMatrix from \"./common.js\";\nimport * as mat3 from \"./mat3.js\";\nimport * as vec3 from \"./vec3.js\";\nimport * as vec4 from \"./vec4.js\";\n\n/**\n * Quaternion in the format XYZW\n * @module quat\n */\n\n/**\n * Creates a new identity quat\n *\n * @returns {quat} a new quaternion\n */\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nexport function identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyVec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\nexport function setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as providied in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\n * @param  {ReadonlyQuat} q     Quaternion to be decomposed\n * @return {Number}     Angle, in radians, of the rotation\n */\nexport function getAxisAngle(out_axis, q) {\n  var rad = Math.acos(q[3]) * 2.0;\n  var s = Math.sin(rad / 2.0);\n  if (s > glMatrix.EPSILON) {\n    out_axis[0] = q[0] / s;\n    out_axis[1] = q[1] / s;\n    out_axis[2] = q[2] / s;\n  } else {\n    // If s is zero, return any axis (no rotation - axis does not matter)\n    out_axis[0] = 1;\n    out_axis[1] = 0;\n    out_axis[2] = 0;\n  }\n  return rad;\n}\n\n/**\n * Gets the angular distance between two unit quaternions\n *\n * @param  {ReadonlyQuat} a     Origin unit quaternion\n * @param  {ReadonlyQuat} b     Destination unit quaternion\n * @return {Number}     Angle, in radians, between the two quaternions\n */\nexport function getAngle(a, b) {\n  var dotproduct = dot(a, b);\n  return Math.acos(2 * dotproduct * dotproduct - 1);\n}\n\n/**\n * Multiplies two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n */\nexport function multiply(out, a, b) {\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  var bx = b[0],\n    by = b[1],\n    bz = b[2],\n    bw = b[3];\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateX(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  var bx = Math.sin(rad),\n    bw = Math.cos(rad);\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateY(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  var by = Math.sin(rad),\n    bw = Math.cos(rad);\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateZ(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  var bz = Math.sin(rad),\n    bw = Math.cos(rad);\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate W component of\n * @returns {quat} out\n */\nexport function calculateW(out, a) {\n  var x = a[0],\n    y = a[1],\n    z = a[2];\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n  return out;\n}\n\n/**\n * Calculate the exponential of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\nexport function exp(out, a) {\n  var x = a[0],\n    y = a[1],\n    z = a[2],\n    w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var et = Math.exp(w);\n  var s = r > 0 ? et * Math.sin(r) / r : 0;\n  out[0] = x * s;\n  out[1] = y * s;\n  out[2] = z * s;\n  out[3] = et * Math.cos(r);\n  return out;\n}\n\n/**\n * Calculate the natural logarithm of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\nexport function ln(out, a) {\n  var x = a[0],\n    y = a[1],\n    z = a[2],\n    w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var t = r > 0 ? Math.atan2(r, w) / r : 0;\n  out[0] = x * t;\n  out[1] = y * t;\n  out[2] = z * t;\n  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);\n  return out;\n}\n\n/**\n * Calculate the scalar power of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @param {Number} b amount to scale the quaternion by\n * @returns {quat} out\n */\nexport function pow(out, a, b) {\n  ln(out, a);\n  scale(out, out, b);\n  exp(out, out);\n  return out;\n}\n\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nexport function slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  var bx = b[0],\n    by = b[1],\n    bz = b[2],\n    bw = b[3];\n  var omega, cosom, sinom, scale0, scale1;\n\n  // calc cosine\n  cosom = ax * bx + ay * by + az * bz + aw * bw;\n  // adjust signs (if necessary)\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  }\n  // calculate coefficients\n  if (1.0 - cosom > glMatrix.EPSILON) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  }\n  // calculate final values\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n\n/**\n * Generates a random unit quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nexport function random(out) {\n  // Implementation of http://planning.cs.uiuc.edu/node198.html\n  // TODO: Calling random 3 times is probably not the fastest solution\n  var u1 = glMatrix.RANDOM();\n  var u2 = glMatrix.RANDOM();\n  var u3 = glMatrix.RANDOM();\n  var sqrt1MinusU1 = Math.sqrt(1 - u1);\n  var sqrtU1 = Math.sqrt(u1);\n  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);\n  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);\n  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);\n  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);\n  return out;\n}\n\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate inverse of\n * @returns {quat} out\n */\nexport function invert(out, a) {\n  var a0 = a[0],\n    a1 = a[1],\n    a2 = a[2],\n    a3 = a[3];\n  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n  var invDot = dot ? 1.0 / dot : 0;\n\n  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0 * invDot;\n  out[1] = -a1 * invDot;\n  out[2] = -a2 * invDot;\n  out[3] = a3 * invDot;\n  return out;\n}\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate conjugate of\n * @returns {quat} out\n */\nexport function conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyMat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\nexport function fromMat3(out, m) {\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  var fTrace = m[0] + m[4] + m[8];\n  var fRoot;\n  if (fTrace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot; // 1/(4w)\n    out[0] = (m[5] - m[7]) * fRoot;\n    out[1] = (m[6] - m[2]) * fRoot;\n    out[2] = (m[1] - m[3]) * fRoot;\n  } else {\n    // |w| <= 1/2\n    var i = 0;\n    if (m[4] > m[0]) i = 1;\n    if (m[8] > m[i * 3 + i]) i = 2;\n    var j = (i + 1) % 3;\n    var k = (i + 2) % 3;\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n  }\n  return out;\n}\n\n/**\n * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x Angle to rotate around X axis in degrees.\n * @param {Number} y Angle to rotate around Y axis in degrees.\n * @param {Number} z Angle to rotate around Z axis in degrees.\n * @param {'xyz'|'xzy'|'yxz'|'yzx'|'zxy'|'zyx'} order Intrinsic order for conversion, default is zyx.\n * @returns {quat} out\n * @function\n */\nexport function fromEuler(out, x, y, z) {\n  var order = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : glMatrix.ANGLE_ORDER;\n  var halfToRad = Math.PI / 360;\n  x *= halfToRad;\n  z *= halfToRad;\n  y *= halfToRad;\n  var sx = Math.sin(x);\n  var cx = Math.cos(x);\n  var sy = Math.sin(y);\n  var cy = Math.cos(y);\n  var sz = Math.sin(z);\n  var cz = Math.cos(z);\n  switch (order) {\n    case \"xyz\":\n      out[0] = sx * cy * cz + cx * sy * sz;\n      out[1] = cx * sy * cz - sx * cy * sz;\n      out[2] = cx * cy * sz + sx * sy * cz;\n      out[3] = cx * cy * cz - sx * sy * sz;\n      break;\n    case \"xzy\":\n      out[0] = sx * cy * cz - cx * sy * sz;\n      out[1] = cx * sy * cz - sx * cy * sz;\n      out[2] = cx * cy * sz + sx * sy * cz;\n      out[3] = cx * cy * cz + sx * sy * sz;\n      break;\n    case \"yxz\":\n      out[0] = sx * cy * cz + cx * sy * sz;\n      out[1] = cx * sy * cz - sx * cy * sz;\n      out[2] = cx * cy * sz - sx * sy * cz;\n      out[3] = cx * cy * cz + sx * sy * sz;\n      break;\n    case \"yzx\":\n      out[0] = sx * cy * cz + cx * sy * sz;\n      out[1] = cx * sy * cz + sx * cy * sz;\n      out[2] = cx * cy * sz - sx * sy * cz;\n      out[3] = cx * cy * cz - sx * sy * sz;\n      break;\n    case \"zxy\":\n      out[0] = sx * cy * cz - cx * sy * sz;\n      out[1] = cx * sy * cz + sx * cy * sz;\n      out[2] = cx * cy * sz + sx * sy * cz;\n      out[3] = cx * cy * cz - sx * sy * sz;\n      break;\n    case \"zyx\":\n      out[0] = sx * cy * cz - cx * sy * sz;\n      out[1] = cx * sy * cz + sx * cy * sz;\n      out[2] = cx * cy * sz - sx * sy * cz;\n      out[3] = cx * cy * cz + sx * sy * sz;\n      break;\n    default:\n      throw new Error('Unknown angle order ' + order);\n  }\n  return out;\n}\n\n/**\n * Returns a string representation of a quaternion\n *\n * @param {ReadonlyQuat} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nexport function str(a) {\n  return \"quat(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {ReadonlyQuat} a quaternion to clone\n * @returns {quat} a new quaternion\n * @function\n */\nexport var clone = vec4.clone;\n\n/**\n * Creates a new quat initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} a new quaternion\n * @function\n */\nexport var fromValues = vec4.fromValues;\n\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the source quaternion\n * @returns {quat} out\n * @function\n */\nexport var copy = vec4.copy;\n\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\nexport var set = vec4.set;\n\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n * @function\n */\nexport var add = vec4.add;\n\n/**\n * Alias for {@link quat.multiply}\n * @function\n */\nexport var mul = multiply;\n\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {ReadonlyQuat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\nexport var scale = vec4.scale;\n\n/**\n * Calculates the dot product of two quat's\n *\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\nexport var dot = vec4.dot;\n\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n * @function\n */\nexport var lerp = vec4.lerp;\n\n/**\n * Calculates the length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport var length = vec4.length;\n\n/**\n * Alias for {@link quat.length}\n * @function\n */\nexport var len = length;\n\n/**\n * Calculates the squared length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\nexport var squaredLength = vec4.squaredLength;\n\n/**\n * Alias for {@link quat.squaredLength}\n * @function\n */\nexport var sqrLen = squaredLength;\n\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\nexport var normalize = vec4.normalize;\n\n/**\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyQuat} a The first quaternion.\n * @param {ReadonlyQuat} b The second quaternion.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport var exactEquals = vec4.exactEquals;\n\n/**\n * Returns whether or not the quaternions point approximately to the same direction.\n *\n * Both quaternions are assumed to be unit length.\n *\n * @param {ReadonlyQuat} a The first unit quaternion.\n * @param {ReadonlyQuat} b The second unit quaternion.\n * @returns {Boolean} True if the quaternions are equal, false otherwise.\n */\nexport function equals(a, b) {\n  return Math.abs(vec4.dot(a, b)) >= 1 - glMatrix.EPSILON;\n}\n\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {ReadonlyVec3} a the initial vector\n * @param {ReadonlyVec3} b the destination vector\n * @returns {quat} out\n */\nexport var rotationTo = function () {\n  var tmpvec3 = vec3.create();\n  var xUnitVec3 = vec3.fromValues(1, 0, 0);\n  var yUnitVec3 = vec3.fromValues(0, 1, 0);\n  return function (out, a, b) {\n    var dot = vec3.dot(a, b);\n    if (dot < -0.999999) {\n      vec3.cross(tmpvec3, xUnitVec3, a);\n      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);\n      vec3.normalize(tmpvec3, tmpvec3);\n      setAxisAngle(out, tmpvec3, Math.PI);\n      return out;\n    } else if (dot > 0.999999) {\n      out[0] = 0;\n      out[1] = 0;\n      out[2] = 0;\n      out[3] = 1;\n      return out;\n    } else {\n      vec3.cross(tmpvec3, a, b);\n      out[0] = tmpvec3[0];\n      out[1] = tmpvec3[1];\n      out[2] = tmpvec3[2];\n      out[3] = 1 + dot;\n      return normalize(out, out);\n    }\n  };\n}();\n\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {ReadonlyQuat} c the third operand\n * @param {ReadonlyQuat} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nexport var sqlerp = function () {\n  var temp1 = create();\n  var temp2 = create();\n  return function (out, a, b, c, d, t) {\n    slerp(temp1, a, d, t);\n    slerp(temp2, b, c, t);\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\n    return out;\n  };\n}();\n\n/**\n * Sets the specified quaternion with values corresponding to the given\n * axes. Each axis is a vec3 and is expected to be unit length and\n * perpendicular to all other specified axes.\n *\n * @param {ReadonlyVec3} view  the vector representing the viewing direction\n * @param {ReadonlyVec3} right the vector representing the local \"right\" direction\n * @param {ReadonlyVec3} up    the vector representing the local \"up\" direction\n * @returns {quat} out\n */\nexport var setAxes = function () {\n  var matr = mat3.create();\n  return function (out, view, right, up) {\n    matr[0] = right[0];\n    matr[3] = right[1];\n    matr[6] = right[2];\n    matr[1] = up[0];\n    matr[4] = up[1];\n    matr[7] = up[2];\n    matr[2] = -view[0];\n    matr[5] = -view[1];\n    matr[8] = -view[2];\n    return normalize(out, fromMat3(out, matr));\n  };\n}();","import { mat4, quat, vec3 } from 'gl-matrix';\n\ntype IVertexDataTypes =\n    | Float32Array\n    | Uint32Array\n    | Int32Array\n    | Uint16Array\n    | Int16Array | Uint8ClampedArray\n    | Uint8Array\n    | Int8Array;\n\ntype IIndicesDataTypes = Uint16Array | Uint32Array;\n\n// Data classes\nclass Scene\n{\n    meshes: Mesh[];\n\n    constructor()\n    {\n        // not 1-1 to meshes in json file\n        // each mesh with a different node hierarchy is a new instance\n        this.meshes = [];\n        // this.meshes = {};\n    }\n}\n\n// Node\nclass Mesh\n{\n    meshID: string;\n    primitives: Primitive[];\n\n    constructor()\n    {\n        this.meshID = ''; // mesh id name in glTF json meshes\n        this.primitives = [];\n    }\n}\n\nexport class Primitive\n{\n    mode: number;\n    indices: IIndicesDataTypes;\n    indicesComponentType: number;\n    vertexBuffer: IVertexDataTypes;\n    matrix: mat4;\n    attributes: {\n        [key: string]: { size: 1 | 2 | 3 | 4, type?: number, stride: number, offset: number },\n    };\n\n    constructor()\n    {\n        this.mode = 4; // default: gl.TRIANGLES\n\n        this.indices = null;\n        this.indicesComponentType = 5123; // default: gl.UNSIGNED_SHORT\n\n        // !!: assume vertex buffer is interleaved\n        // see discussion https://github.com/KhronosGroup/glTF/issues/21\n        this.vertexBuffer = null;\n\n        this.matrix = mat4.create();\n\n        // attribute info (stride, offset, etc)\n        this.attributes = {};\n    }\n}\n\nexport class GlTFModel\n{\n    defaultScene: string;\n    scenes: {};\n    json: null;\n\n    constructor()\n    {\n        this.defaultScene = '';\n        this.scenes = {};\n\n        this.json = null;\n    }\n}\n\nexport class GlTFLoader\n{\n    glTF: GlTFModel;\n    _parseDone: boolean;\n    _loadDone: boolean;\n    _bufferRequested: number;\n    _bufferLoaded: number;\n    _buffers: {};\n    _bufferTasks: {};\n    _bufferViews: {};\n    _pendingTasks: number;\n    _finishedPendingTasks: number;\n    onload: (glTF: GlTFModel) => void;\n    baseUri: string;\n\n    constructor()\n    {\n        this._init();\n        this.glTF = null;\n    }\n\n    _init()\n    {\n        this._parseDone = false;\n        this._loadDone = false;\n\n        this._bufferRequested = 0;\n        this._bufferLoaded = 0;\n        this._buffers = {};\n        this._bufferTasks = {};\n\n        this._bufferViews = {};\n\n        this._pendingTasks = 0;\n        this._finishedPendingTasks = 0;\n\n        this.onload = null;\n    }\n\n    _getBufferViewData(json, bufferViewID, callback)\n    {\n        const bufferViewData = this._bufferViews[bufferViewID];\n\n        if (!bufferViewData)\n        {\n            // load bufferView for the first time\n            const bufferView = json.bufferViews[bufferViewID];\n            const bufferData = this._buffers[bufferView.buffer];\n\n            if (bufferData)\n            {\n                // buffer already loaded\n                // console.log(\"dependent buffer ready, create bufferView\" + bufferViewID);\n                this._bufferViews[bufferViewID] = bufferData.slice(bufferView.byteOffset, bufferView.byteOffset + bufferView.byteLength);\n                callback(bufferViewData);\n            }\n            else\n            {\n                // buffer not yet loaded\n                // add pending task to _bufferTasks\n                // console.log(\"pending Task: wait for buffer to load bufferView \" + bufferViewID);\n                this._pendingTasks++;\n                let bufferTask = this._bufferTasks[bufferView.buffer];\n\n                if (!bufferTask)\n                {\n                    this._bufferTasks[bufferView.buffer] = [];\n                    bufferTask = this._bufferTasks[bufferView.buffer];\n                }\n                const loader = this;\n\n                bufferTask.push(function (newBufferData)\n                {\n                    // share same bufferView\n                    // hierarchy needs to be post processed in the renderer\n                    let curBufferViewData = loader._bufferViews[bufferViewID];\n\n                    if (!curBufferViewData)\n                    {\n                        console.log(`create new BufferView Data for ${bufferViewID}`);\n                        curBufferViewData = loader._bufferViews[bufferViewID] = newBufferData.slice(bufferView.byteOffset, bufferView.byteOffset + bufferView.byteLength);\n                    }\n                    loader._finishedPendingTasks++;\n                    callback(curBufferViewData);\n\n                    // // create new bufferView for each mesh access with a different hierarchy\n                    // // hierarchy transformation will be prepared in this way\n                    // console.log('create new BufferView Data for ' + bufferViewID);\n                    // loader._bufferViews[bufferViewID] = newBufferData.slice(bufferView.byteOffset, bufferView.byteOffset + bufferView.byteLength);\n                    // loader._finishedPendingTasks++;\n                    // callback(loader._bufferViews[bufferViewID]);\n                });\n            }\n        }\n        else\n        {\n            // no need to load buffer from file\n            // use cached ones\n            // console.log(\"use cached bufferView \" + bufferViewID);\n            callback(bufferViewData);\n        }\n    }\n\n    _checkComplete()\n    {\n        if (this._bufferRequested === this._bufferLoaded\n        // && other resources finish loading\n        )\n        {\n            this._loadDone = true;\n        }\n\n        if (this._loadDone && this._parseDone && this._pendingTasks === this._finishedPendingTasks)\n        {\n            this.onload(this.glTF);\n        }\n    }\n\n    _parseGLTF(json)\n    {\n        this.glTF.json = json;\n        this.glTF.defaultScene = json.scene;\n\n        // Iterate through every scene\n        for (const sceneID in json.scenes)\n        {\n            const newScene = new Scene();\n\n            this.glTF.scenes[sceneID] = newScene;\n\n            const scene = json.scenes[sceneID];\n            const nodes = scene.nodes;\n            const nodeLen = nodes.length;\n\n            // Iterate through every node within scene\n            for (let n = 0; n < nodeLen; ++n)\n            {\n                const nodeName = nodes[n];\n                const node = json.nodes[nodeName];\n\n                // Traverse node\n                this._parseNode(json, node, newScene);\n            }\n        }\n\n        this._parseDone = true;\n        this._checkComplete();\n    }\n\n    _parseNode(json, node, newScene, matrix?)\n    {\n        if (matrix === undefined)\n        {\n            matrix = mat4.create();\n        }\n\n        const curMatrix = mat4.create();\n\n        if (node.hasOwnProperty('matrix'))\n        {\n            // matrix\n            for (let i = 0; i < 16; ++i)\n            {\n                curMatrix[i] = node.matrix[i];\n            }\n            mat4.multiply(curMatrix, matrix, curMatrix);\n            // mat4.multiply(curMatrix, curMatrix, matrix);\n        }\n        else\n        {\n            // translation, rotation, scale (TRS)\n            // TODO: these labels are optional\n            vec3.set(translationVec3, node.translation[0], node.translation[1], node.translation[2]);\n            quat.set(rotationQuat, node.rotation[0], node.rotation[1], node.rotation[2], node.rotation[3]);\n            mat4.fromRotationTranslation(TRMatrix, rotationQuat, translationVec3);\n            mat4.multiply(curMatrix, curMatrix, TRMatrix);\n            vec3.set(scaleVec3, node.scale[0], node.scale[1], node.scale[2]);\n            mat4.scale(curMatrix, curMatrix, scaleVec3);\n        }\n\n        // Iterate through every mesh within node\n        const meshes = node.meshes;\n\n        if (meshes)\n        {\n            const meshLen = meshes.length;\n\n            for (let m = 0; m < meshLen; ++m)\n            {\n                const newMesh = new Mesh();\n\n                newScene.meshes.push(newMesh);\n\n                const meshName = meshes[m];\n                const mesh = json.meshes[meshName];\n\n                newMesh.meshID = meshName;\n\n                // Iterate through primitives\n                const primitives = mesh.primitives;\n                const primitiveLen = primitives.length;\n\n                for (let p = 0; p < primitiveLen; ++p)\n                {\n                    const newPrimitive = new Primitive();\n\n                    newMesh.primitives.push(newPrimitive);\n\n                    const primitive = primitives[p];\n\n                    if (primitive.indices)\n                    {\n                        this._parseIndices(json, primitive, newPrimitive);\n                    }\n\n                    this._parseAttributes(json, primitive, newPrimitive, curMatrix);\n                }\n            }\n        }\n\n        // Go through all the children recursively\n        const children = node.children;\n        const childreLen = children.length;\n\n        for (let c = 0; c < childreLen; ++c)\n        {\n            const childName = children[c];\n            const childNode = json.nodes[childName];\n\n            this._parseNode(json, childNode, newScene, curMatrix);\n        }\n    }\n\n    _parseIndices(json, primitive, newPrimitive: Primitive)\n    {\n        const accessorName = primitive.indices;\n        const accessor = json.accessors[accessorName];\n\n        newPrimitive.mode = primitive.mode || 4;\n        newPrimitive.indicesComponentType = IDrawElementType2Name[accessor.componentType];\n\n        const loader = this;\n\n        this._getBufferViewData(json, accessor.bufferView, function (bufferViewData)\n        {\n            newPrimitive.indices = _getAccessorData(bufferViewData, accessor) as any;\n            loader._checkComplete();\n        });\n    }\n\n    _parseAttributes(json, primitive, newPrimitive: Primitive, matrix)\n    {\n        // !! Assume interleaved vertex attributes\n        // i.e., all attributes share one bufferView\n\n        // vertex buffer processing\n        const firstSemantic = Object.keys(primitive.attributes)[0];\n        const firstAccessor = json.accessors[primitive.attributes[firstSemantic]];\n        const vertexBufferViewID = firstAccessor.bufferView;\n        const bufferView = json.bufferViews[vertexBufferViewID];\n\n        const loader = this;\n\n        this._getBufferViewData(json, vertexBufferViewID, function (bufferViewData)\n        {\n            const data = newPrimitive.vertexBuffer = _arrayBuffer2TypedArray(\n                bufferViewData,\n                0,\n                bufferView.byteLength / ComponentType2ByteSize[firstAccessor.componentType],\n                firstAccessor.componentType,\n            );\n\n            for (const attributeName in primitive.attributes)\n            {\n                const accessorName = primitive.attributes[attributeName];\n                const accessor = json.accessors[accessorName];\n\n                const componentTypeByteSize = ComponentType2ByteSize[accessor.componentType];\n\n                const stride = accessor.byteStride / componentTypeByteSize;\n                const offset = accessor.byteOffset / componentTypeByteSize;\n                const count = accessor.count;\n\n                // // Matrix transformation\n                // if (attributeName === 'POSITION') {\n                //     for (var i = 0; i < count; ++i) {\n                //         // TODO: add vec2 and other(needed?) support\n                //         vec4.set(tmpVec4, data[stride * i + offset]\n                //                         , data[stride * i + offset + 1]\n                //                         , data[stride * i + offset + 2]\n                //                         , 1);\n                //         vec4.transformMat4(tmpVec4, tmpVec4, matrix);\n                //         vec4.scale(tmpVec4, tmpVec4, 1 / tmpVec4[3]);\n                //         data[stride * i + offset] = tmpVec4[0];\n                //         data[stride * i + offset + 1] = tmpVec4[1];\n                //         data[stride * i + offset + 2] = tmpVec4[2];\n                //     }\n                // }\n                // else if (attributeName === 'NORMAL') {\n                //     mat4.invert(inverseTransposeMatrix, matrix);\n                //     mat4.transpose(inverseTransposeMatrix, inverseTransposeMatrix);\n\n                //     for (var i = 0; i < count; ++i) {\n                //         // @todo: add vec2 and other(needed?) support\n                //         vec4.set(tmpVec4, data[stride * i + offset]\n                //                         , data[stride * i + offset + 1]\n                //                         , data[stride * i + offset + 2]\n                //                         , 0);\n                //         vec4.transformMat4(tmpVec4, tmpVec4, inverseTransposeMatrix);\n                //         vec4.normalize(tmpVec4, tmpVec4);\n                //         data[stride * i + offset] = tmpVec4[0];\n                //         data[stride * i + offset + 1] = tmpVec4[1];\n                //         data[stride * i + offset + 2] = tmpVec4[2];\n                //     }\n                // }\n\n                // local transform matrix\n\n                mat4.copy(newPrimitive.matrix, matrix);\n\n                // for vertexAttribPointer\n                newPrimitive.attributes[attributeName] = {\n                    // GLuint program location,\n                    size: Type2NumOfComponent[accessor.type],\n                    type: accessor.componentType,\n                    // GLboolean normalized\n                    stride: accessor.byteStride,\n                    offset: accessor.byteOffset,\n                };\n            }\n\n            loader._checkComplete();\n        });\n    }\n\n    /**\n     * load a glTF model\n     *\n     * @param {String} uri uri of the .glTF file. Other resources (bins, images) are assumed to be in the same base path\n     * @param {Function} callback the onload callback function\n     */\n    loadGLTF(uri, callback)\n    {\n        this._init();\n\n        this.onload = callback || ((glTF) =>\n        {\n            console.log('glTF model loaded.');\n            console.log(glTF);\n        });\n\n        this.glTF = new GlTFModel();\n\n        this.baseUri = _getBaseUri(uri);\n\n        const loader = this;\n\n        _loadJSON(uri, function (response)\n        {\n            // Parse JSON string into object\n            const json = JSON.parse(response);\n\n            let b;\n\n            const loadArrayBufferCallback = (resource) =>\n            {\n                loader._buffers[b] = resource;\n                loader._bufferLoaded++;\n                if (loader._bufferTasks[b])\n                {\n                    let i; let len;\n\n                    for (i = 0, len = loader._bufferTasks[b].length; i < len; ++i)\n                    {\n                        (loader._bufferTasks[b][i])(resource);\n                    }\n                }\n                loader._checkComplete();\n            };\n\n            // Launch loading resources: buffers, images, etc.\n            if (json.buffers)\n            {\n                for (b in json.buffers)\n                {\n                    loader._bufferRequested++;\n\n                    _loadArrayBuffer(`${loader.baseUri}/${json.buffers[b].uri}`, loadArrayBufferCallback);\n                }\n            }\n\n            // Meanwhile start glTF scene parsing\n            loader._parseGLTF(json);\n        });\n    }\n}\n\nconst translationVec3 = vec3.create();\nconst rotationQuat = quat.create();\nconst scaleVec3 = vec3.create();\nconst TRMatrix = mat4.create();\n\n// TODO: get from gl context\nconst ComponentType2ByteSize = {\n    5120: 1, // BYTE\n    5121: 1, // UNSIGNED_BYTE\n    5122: 2, // SHORT\n    5123: 2, // UNSIGNED_SHORT\n    5126: 4, // FLOAT\n};\n\nconst Type2NumOfComponent = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16,\n};\n\nconst IDrawElementType2Name = {\n    5121: 'UNSIGNED_BYTE',\n    5123: 'UNSIGNED_SHORT',\n    5124: 'UNSIGNED_INT',\n};\n\nexport const Attributes = [\n    'POSITION',\n    'NORMAL',\n    'TEXCOORD',\n    'COLOR',\n    'JOINT',\n    'WEIGHT',\n];\n\n// ------ Scope limited private util functions---------------\n\nfunction _arrayBuffer2TypedArray(resource, byteOffset, countOfComponentType, componentType)\n{\n    switch (componentType)\n    {\n        // @todo: finish\n        case 5122: return new Int16Array(resource, byteOffset, countOfComponentType);\n        case 5123: return new Uint16Array(resource, byteOffset, countOfComponentType);\n        case 5126: return new Float32Array(resource, byteOffset, countOfComponentType);\n        default: return null;\n    }\n}\n\nfunction _getAccessorData(bufferViewData, accessor)\n{\n    return _arrayBuffer2TypedArray(\n        bufferViewData,\n        accessor.byteOffset,\n        accessor.count * Type2NumOfComponent[accessor.type],\n        accessor.componentType,\n    );\n}\n\nfunction _getBaseUri(uri)\n{\n    // https://github.com/AnalyticalGraphicsInc/cesium/blob/master/Source/Core/getBaseUri.js\n\n    let basePath = '';\n    const i = uri.lastIndexOf('/');\n\n    if (i !== -1)\n    {\n        basePath = uri.substring(0, i + 1);\n    }\n\n    return basePath;\n}\n\nfunction _loadJSON(src, callback)\n{\n    // native json loading technique from @KryptoniteDove:\n    // http://codepen.io/KryptoniteDove/post/load-json-file-locally-using-pure-javascript\n\n    const xobj = new XMLHttpRequest();\n\n    xobj.overrideMimeType('application/json');\n    xobj.open('GET', src, true);\n    xobj.onreadystatechange = function ()\n    {\n        if (xobj.readyState === 4 // Request finished, response ready\n            && xobj.status === 200)\n        { // Status OK\n            callback(xobj.responseText, this);\n        }\n    };\n    xobj.send(null);\n}\n\nfunction _loadArrayBuffer(url, callback)\n{\n    const xobj = new XMLHttpRequest();\n\n    xobj.responseType = 'arraybuffer';\n    xobj.open('GET', url, true);\n    xobj.onreadystatechange = function ()\n    {\n        if (xobj.readyState === 4 // Request finished, response ready\n            && xobj.status === 200)\n        { // Status OK\n            const arrayBuffer = xobj.response;\n\n            if (arrayBuffer && callback)\n            {\n                callback(arrayBuffer);\n            }\n        }\n    };\n    xobj.send(null);\n}"],"names":["create","out","glMatrix.ARRAY_TYPE","set","x","y","z","w","normalize","a","len","vec","stride","offset","count","fn","arg","i","l","setAxisAngle","axis","rad","s","slerp","b","t","ax","ay","az","aw","bx","by","bz","bw","omega","cosom","sinom","scale0","scale1","glMatrix.EPSILON","fromMat3","m","fTrace","fRoot","j","k","vec4.set","vec4.normalize","tmpvec3","vec3.create","xUnitVec3","vec3.fromValues","yUnitVec3","dot","vec3.dot","vec3.cross","vec3.len","vec3.normalize","temp1","temp2","c","d","matr","mat3.create","view","right","up","Scene","Mesh","Primitive","mat4.create","GlTFModel","GlTFLoader","json","bufferViewID","callback","bufferViewData","bufferView","bufferData","bufferTask","loader","newBufferData","curBufferViewData","sceneID","newScene","nodes","nodeLen","n","nodeName","node","matrix","curMatrix","mat4.multiply","vec3.set","translationVec3","quat.set","rotationQuat","mat4.fromRotationTranslation","TRMatrix","scaleVec3","mat4.scale","meshes","meshLen","newMesh","meshName","mesh","primitives","primitiveLen","newPrimitive","primitive","children","childreLen","childName","childNode","accessorName","accessor","IDrawElementType2Name","_getAccessorData","firstSemantic","firstAccessor","vertexBufferViewID","_arrayBuffer2TypedArray","ComponentType2ByteSize","attributeName","componentTypeByteSize","mat4.copy","Type2NumOfComponent","uri","glTF","_getBaseUri","_loadJSON","response","loadArrayBufferCallback","resource","_loadArrayBuffer","quat.create","byteOffset","countOfComponentType","componentType","basePath","src","xobj","url","arrayBuffer"],"mappings":"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","x_google_ignoreList":[0,1,2]}