{"version":3,"file":"gltf-loader-b07d1c9b.js","sources":["../../node_modules/gl-matrix/esm/mat3.js","../../node_modules/gl-matrix/esm/vec4.js","../../node_modules/gl-matrix/esm/quat.js","../../examples/src/WebGL2Samples/third-party/gltf-loader.ts"],"sourcesContent":["import * as glMatrix from \"./common.js\";\n/**\n * 3x3 Matrix\n * @module mat3\n */\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(9);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {ReadonlyMat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\n\nexport function fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Create a new mat3 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} A new mat3\n */\n\nexport function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} out\n */\n\nexport function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b01 = a22 * a11 - a12 * a21;\n  var b11 = -a22 * a10 + a12 * a20;\n  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant\n\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  out[0] = a11 * a22 - a12 * a21;\n  out[1] = a02 * a21 - a01 * a22;\n  out[2] = a01 * a12 - a02 * a11;\n  out[3] = a12 * a20 - a10 * a22;\n  out[4] = a00 * a22 - a02 * a20;\n  out[5] = a02 * a10 - a00 * a12;\n  out[6] = a10 * a21 - a11 * a20;\n  out[7] = a01 * a20 - a00 * a21;\n  out[8] = a00 * a11 - a01 * a10;\n  return out;\n}\n/**\n * Calculates the determinant of a mat3\n *\n * @param {ReadonlyMat3} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b00 = b[0],\n      b01 = b[1],\n      b02 = b[2];\n  var b10 = b[3],\n      b11 = b[4],\n      b12 = b[5];\n  var b20 = b[6],\n      b21 = b[7],\n      b22 = b[8];\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to translate\n * @param {ReadonlyVec2} v vector to translate by\n * @returns {mat3} out\n */\n\nexport function translate(out, a, v) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      x = v[0],\n      y = v[1];\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nexport function rotate(out, a, rad) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n}\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1];\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.translate(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Translation vector\n * @returns {mat3} out\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = v[0];\n  out[7] = v[1];\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.rotate(dest, dest, rad);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nexport function fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = -s;\n  out[4] = c;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.scale(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat3} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to copy\n * @returns {mat3} out\n **/\n\nexport function fromMat2d(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = 0;\n  out[3] = a[2];\n  out[4] = a[3];\n  out[5] = 0;\n  out[6] = a[4];\n  out[7] = a[5];\n  out[8] = 1;\n  return out;\n}\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n  return out;\n}\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */\n\nexport function normalFromMat4(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return out;\n}\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\n\nexport function projection(out, width, height) {\n  out[0] = 2 / width;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -2 / height;\n  out[5] = 0;\n  out[6] = -1;\n  out[7] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat3\n *\n * @param {ReadonlyMat3} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);\n}\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n/**\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat3} out the receiving vector\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat3} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7],\n      a8 = a[8];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7],\n      b8 = b[8];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));\n}\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat3.subtract}\n * @function\n */\n\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\n/**\n * 4 Dimensional Vector\n * @module vec4\n */\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {ReadonlyVec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\n\nexport function fromValues(x, y, z, w) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the source vector\n * @returns {vec4} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\n\nexport function set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n/**\n * Math.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to ceil\n * @returns {vec4} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n/**\n * Math.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to floor\n * @returns {vec4} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n/**\n * Math.round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to round\n * @returns {vec4} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Calculates the length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to negate\n * @returns {vec4} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to invert\n * @returns {vec4} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to normalize\n * @returns {vec4} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param {ReadonlyVec4} result the receiving vector\n * @param {ReadonlyVec4} U the first vector\n * @param {ReadonlyVec4} V the second vector\n * @param {ReadonlyVec4} W the third vector\n * @returns {vec4} result\n */\n\nexport function cross(out, u, v, w) {\n  var A = v[0] * w[1] - v[1] * w[0],\n      B = v[0] * w[2] - v[2] * w[0],\n      C = v[0] * w[3] - v[3] * w[0],\n      D = v[1] * w[2] - v[2] * w[1],\n      E = v[1] * w[3] - v[3] * w[1],\n      F = v[2] * w[3] - v[3] * w[2];\n  var G = u[0];\n  var H = u[1];\n  var I = u[2];\n  var J = u[3];\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec4} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec4} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n\n  var v1, v2, v3, v4;\n  var s1, s2;\n\n  do {\n    v1 = glMatrix.RANDOM() * 2 - 1;\n    v2 = glMatrix.RANDOM() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n\n  do {\n    v3 = glMatrix.RANDOM() * 2 - 1;\n    v4 = glMatrix.RANDOM() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec4} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec4} out\n */\n\nexport function transformQuat(out, a, q) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3]; // calculate quat * vec\n\n  var ix = qw * x + qy * z - qz * y;\n  var iy = qw * y + qz * x - qx * z;\n  var iz = qw * z + qx * y - qy * x;\n  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to zero\n *\n * @param {vec4} out the receiving vector\n * @returns {vec4} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec4} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec4.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 4;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n\n    return a;\n  };\n}();","import * as glMatrix from \"./common.js\";\nimport * as mat3 from \"./mat3.js\";\nimport * as vec3 from \"./vec3.js\";\nimport * as vec4 from \"./vec4.js\";\n/**\n * Quaternion\n * @module quat\n */\n\n/**\n * Creates a new identity quat\n *\n * @returns {quat} a new quaternion\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  out[3] = 1;\n  return out;\n}\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\n\nexport function identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyVec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\n\nexport function setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as providied in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\n * @param  {ReadonlyQuat} q     Quaternion to be decomposed\n * @return {Number}     Angle, in radians, of the rotation\n */\n\nexport function getAxisAngle(out_axis, q) {\n  var rad = Math.acos(q[3]) * 2.0;\n  var s = Math.sin(rad / 2.0);\n\n  if (s > glMatrix.EPSILON) {\n    out_axis[0] = q[0] / s;\n    out_axis[1] = q[1] / s;\n    out_axis[2] = q[2] / s;\n  } else {\n    // If s is zero, return any axis (no rotation - axis does not matter)\n    out_axis[0] = 1;\n    out_axis[1] = 0;\n    out_axis[2] = 0;\n  }\n\n  return rad;\n}\n/**\n * Gets the angular distance between two unit quaternions\n *\n * @param  {ReadonlyQuat} a     Origin unit quaternion\n * @param  {ReadonlyQuat} b     Destination unit quaternion\n * @return {Number}     Angle, in radians, between the two quaternions\n */\n\nexport function getAngle(a, b) {\n  var dotproduct = dot(a, b);\n  return Math.acos(2 * dotproduct * dotproduct - 1);\n}\n/**\n * Multiplies two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n */\n\nexport function multiply(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nexport function rotateX(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nexport function rotateY(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var by = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nexport function rotateZ(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bz = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate W component of\n * @returns {quat} out\n */\n\nexport function calculateW(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n  return out;\n}\n/**\n * Calculate the exponential of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\n\nexport function exp(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var et = Math.exp(w);\n  var s = r > 0 ? et * Math.sin(r) / r : 0;\n  out[0] = x * s;\n  out[1] = y * s;\n  out[2] = z * s;\n  out[3] = et * Math.cos(r);\n  return out;\n}\n/**\n * Calculate the natural logarithm of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\n\nexport function ln(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var t = r > 0 ? Math.atan2(r, w) / r : 0;\n  out[0] = x * t;\n  out[1] = y * t;\n  out[2] = z * t;\n  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);\n  return out;\n}\n/**\n * Calculate the scalar power of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @param {Number} b amount to scale the quaternion by\n * @returns {quat} out\n */\n\nexport function pow(out, a, b) {\n  ln(out, a);\n  scale(out, out, b);\n  exp(out, out);\n  return out;\n}\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\n\nexport function slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  var omega, cosom, sinom, scale0, scale1; // calc cosine\n\n  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  } // calculate coefficients\n\n\n  if (1.0 - cosom > glMatrix.EPSILON) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  } // calculate final values\n\n\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n/**\n * Generates a random unit quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\n\nexport function random(out) {\n  // Implementation of http://planning.cs.uiuc.edu/node198.html\n  // TODO: Calling random 3 times is probably not the fastest solution\n  var u1 = glMatrix.RANDOM();\n  var u2 = glMatrix.RANDOM();\n  var u3 = glMatrix.RANDOM();\n  var sqrt1MinusU1 = Math.sqrt(1 - u1);\n  var sqrtU1 = Math.sqrt(u1);\n  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);\n  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);\n  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);\n  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);\n  return out;\n}\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate inverse of\n * @returns {quat} out\n */\n\nexport function invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0 * invDot;\n  out[1] = -a1 * invDot;\n  out[2] = -a2 * invDot;\n  out[3] = a3 * invDot;\n  return out;\n}\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate conjugate of\n * @returns {quat} out\n */\n\nexport function conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyMat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\n\nexport function fromMat3(out, m) {\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  var fTrace = m[0] + m[4] + m[8];\n  var fRoot;\n\n  if (fTrace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\n\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot; // 1/(4w)\n\n    out[0] = (m[5] - m[7]) * fRoot;\n    out[1] = (m[6] - m[2]) * fRoot;\n    out[2] = (m[1] - m[3]) * fRoot;\n  } else {\n    // |w| <= 1/2\n    var i = 0;\n    if (m[4] > m[0]) i = 1;\n    if (m[8] > m[i * 3 + i]) i = 2;\n    var j = (i + 1) % 3;\n    var k = (i + 2) % 3;\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n  }\n\n  return out;\n}\n/**\n * Creates a quaternion from the given euler angle x, y, z.\n *\n * @param {quat} out the receiving quaternion\n * @param {x} Angle to rotate around X axis in degrees.\n * @param {y} Angle to rotate around Y axis in degrees.\n * @param {z} Angle to rotate around Z axis in degrees.\n * @returns {quat} out\n * @function\n */\n\nexport function fromEuler(out, x, y, z) {\n  var halfToRad = 0.5 * Math.PI / 180.0;\n  x *= halfToRad;\n  y *= halfToRad;\n  z *= halfToRad;\n  var sx = Math.sin(x);\n  var cx = Math.cos(x);\n  var sy = Math.sin(y);\n  var cy = Math.cos(y);\n  var sz = Math.sin(z);\n  var cz = Math.cos(z);\n  out[0] = sx * cy * cz - cx * sy * sz;\n  out[1] = cx * sy * cz + sx * cy * sz;\n  out[2] = cx * cy * sz - sx * sy * cz;\n  out[3] = cx * cy * cz + sx * sy * sz;\n  return out;\n}\n/**\n * Returns a string representation of a quatenion\n *\n * @param {ReadonlyQuat} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"quat(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {ReadonlyQuat} a quaternion to clone\n * @returns {quat} a new quaternion\n * @function\n */\n\nexport var clone = vec4.clone;\n/**\n * Creates a new quat initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} a new quaternion\n * @function\n */\n\nexport var fromValues = vec4.fromValues;\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the source quaternion\n * @returns {quat} out\n * @function\n */\n\nexport var copy = vec4.copy;\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\n\nexport var set = vec4.set;\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n * @function\n */\n\nexport var add = vec4.add;\n/**\n * Alias for {@link quat.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {ReadonlyQuat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\n\nexport var scale = vec4.scale;\n/**\n * Calculates the dot product of two quat's\n *\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\n\nexport var dot = vec4.dot;\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n * @function\n */\n\nexport var lerp = vec4.lerp;\n/**\n * Calculates the length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport var length = vec4.length;\n/**\n * Alias for {@link quat.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Calculates the squared length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\n\nexport var squaredLength = vec4.squaredLength;\n/**\n * Alias for {@link quat.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\n\nexport var normalize = vec4.normalize;\n/**\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyQuat} a The first quaternion.\n * @param {ReadonlyQuat} b The second quaternion.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport var exactEquals = vec4.exactEquals;\n/**\n * Returns whether or not the quaternions have approximately the same elements in the same position.\n *\n * @param {ReadonlyQuat} a The first vector.\n * @param {ReadonlyQuat} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport var equals = vec4.equals;\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {ReadonlyVec3} a the initial vector\n * @param {ReadonlyVec3} b the destination vector\n * @returns {quat} out\n */\n\nexport var rotationTo = function () {\n  var tmpvec3 = vec3.create();\n  var xUnitVec3 = vec3.fromValues(1, 0, 0);\n  var yUnitVec3 = vec3.fromValues(0, 1, 0);\n  return function (out, a, b) {\n    var dot = vec3.dot(a, b);\n\n    if (dot < -0.999999) {\n      vec3.cross(tmpvec3, xUnitVec3, a);\n      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);\n      vec3.normalize(tmpvec3, tmpvec3);\n      setAxisAngle(out, tmpvec3, Math.PI);\n      return out;\n    } else if (dot > 0.999999) {\n      out[0] = 0;\n      out[1] = 0;\n      out[2] = 0;\n      out[3] = 1;\n      return out;\n    } else {\n      vec3.cross(tmpvec3, a, b);\n      out[0] = tmpvec3[0];\n      out[1] = tmpvec3[1];\n      out[2] = tmpvec3[2];\n      out[3] = 1 + dot;\n      return normalize(out, out);\n    }\n  };\n}();\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {ReadonlyQuat} c the third operand\n * @param {ReadonlyQuat} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\n\nexport var sqlerp = function () {\n  var temp1 = create();\n  var temp2 = create();\n  return function (out, a, b, c, d, t) {\n    slerp(temp1, a, d, t);\n    slerp(temp2, b, c, t);\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\n    return out;\n  };\n}();\n/**\n * Sets the specified quaternion with values corresponding to the given\n * axes. Each axis is a vec3 and is expected to be unit length and\n * perpendicular to all other specified axes.\n *\n * @param {ReadonlyVec3} view  the vector representing the viewing direction\n * @param {ReadonlyVec3} right the vector representing the local \"right\" direction\n * @param {ReadonlyVec3} up    the vector representing the local \"up\" direction\n * @returns {quat} out\n */\n\nexport var setAxes = function () {\n  var matr = mat3.create();\n  return function (out, view, right, up) {\n    matr[0] = right[0];\n    matr[3] = right[1];\n    matr[6] = right[2];\n    matr[1] = up[0];\n    matr[4] = up[1];\n    matr[7] = up[2];\n    matr[2] = -view[0];\n    matr[5] = -view[1];\n    matr[8] = -view[2];\n    return normalize(out, fromMat3(out, matr));\n  };\n}();","import { mat4, quat, vec3 } from \"gl-matrix\";\n\ntype IVertexDataTypes =\n    | Float32Array\n    | Uint32Array\n    | Int32Array\n    | Uint16Array\n    | Int16Array | Uint8ClampedArray\n    | Uint8Array\n    | Int8Array;\n\ntype IIndicesDataTypes = Uint16Array | Uint32Array;\n\n// Data classes\nclass Scene\n{\n    meshes: Mesh[];\n\n    constructor()\n    {\n        // not 1-1 to meshes in json file\n        // each mesh with a different node hierarchy is a new instance\n        this.meshes = [];\n        //this.meshes = {};\n    }\n}\n\n// Node\nclass Mesh\n{\n    meshID: string;\n    primitives: Primitive[];\n\n    constructor()\n    {\n        this.meshID = \"\"; // mesh id name in glTF json meshes\n        this.primitives = [];\n    }\n}\n\nexport class Primitive\n{\n    mode: number;\n    indices: IIndicesDataTypes;\n    indicesComponentType: number;\n    vertexBuffer: IVertexDataTypes;\n    matrix: mat4;\n    attributes: {\n        [key: string]: { size: 1 | 2 | 3 | 4, type?: number, stride: number, offset: number },\n    };\n    constructor()\n    {\n        this.mode = 4; // default: gl.TRIANGLES\n\n        this.indices = null;\n        this.indicesComponentType = 5123; // default: gl.UNSIGNED_SHORT\n\n        // !!: assume vertex buffer is interleaved\n        // see discussion https://github.com/KhronosGroup/glTF/issues/21\n        this.vertexBuffer = null;\n\n        this.matrix = mat4.create();\n\n        // attribute info (stride, offset, etc)\n        this.attributes = {};\n    }\n}\n\nexport class GlTFModel\n{\n    defaultScene: string;\n    scenes: {};\n    json: null;\n\n    constructor()\n    {\n        this.defaultScene = \"\";\n        this.scenes = {};\n\n        this.json = null;\n    }\n}\n\nexport class GlTFLoader\n{\n    glTF: GlTFModel;\n    _parseDone: boolean;\n    _loadDone: boolean;\n    _bufferRequested: number;\n    _bufferLoaded: number;\n    _buffers: {};\n    _bufferTasks: {};\n    _bufferViews: {};\n    _pendingTasks: number;\n    _finishedPendingTasks: number;\n    onload: (glTF: GlTFModel) => void;\n    baseUri: string;\n\n    constructor()\n    {\n        this._init();\n        this.glTF = null;\n    }\n\n    _init()\n    {\n        this._parseDone = false;\n        this._loadDone = false;\n\n        this._bufferRequested = 0;\n        this._bufferLoaded = 0;\n        this._buffers = {};\n        this._bufferTasks = {};\n\n        this._bufferViews = {};\n\n        this._pendingTasks = 0;\n        this._finishedPendingTasks = 0;\n\n        this.onload = null;\n    }\n\n    _getBufferViewData(json, bufferViewID, callback)\n    {\n        const bufferViewData = this._bufferViews[bufferViewID];\n        if (!bufferViewData)\n        {\n            // load bufferView for the first time\n            const bufferView = json.bufferViews[bufferViewID];\n            const bufferData = this._buffers[bufferView.buffer];\n            if (bufferData)\n            {\n                // buffer already loaded\n                //console.log(\"dependent buffer ready, create bufferView\" + bufferViewID);\n                this._bufferViews[bufferViewID] = bufferData.slice(bufferView.byteOffset, bufferView.byteOffset + bufferView.byteLength);\n                callback(bufferViewData);\n            }\n            else\n            {\n                // buffer not yet loaded\n                // add pending task to _bufferTasks\n                //console.log(\"pending Task: wait for buffer to load bufferView \" + bufferViewID);\n                this._pendingTasks++;\n                let bufferTask = this._bufferTasks[bufferView.buffer];\n                if (!bufferTask)\n                {\n                    this._bufferTasks[bufferView.buffer] = [];\n                    bufferTask = this._bufferTasks[bufferView.buffer];\n                }\n                const loader = this;\n                bufferTask.push(function (newBufferData)\n                {\n                    // share same bufferView\n                    // hierarchy needs to be post processed in the renderer\n                    let curBufferViewData = loader._bufferViews[bufferViewID];\n                    if (!curBufferViewData)\n                    {\n                        console.log(`create new BufferView Data for ${bufferViewID}`);\n                        curBufferViewData = loader._bufferViews[bufferViewID] = newBufferData.slice(bufferView.byteOffset, bufferView.byteOffset + bufferView.byteLength);\n                    }\n                    loader._finishedPendingTasks++;\n                    callback(curBufferViewData);\n\n                    // // create new bufferView for each mesh access with a different hierarchy\n                    // // hierarchy transformation will be prepared in this way\n                    // console.log('create new BufferView Data for ' + bufferViewID);\n                    // loader._bufferViews[bufferViewID] = newBufferData.slice(bufferView.byteOffset, bufferView.byteOffset + bufferView.byteLength);\n                    // loader._finishedPendingTasks++;\n                    // callback(loader._bufferViews[bufferViewID]);\n                });\n            }\n        }\n        else\n        {\n            // no need to load buffer from file\n            // use cached ones\n            //console.log(\"use cached bufferView \" + bufferViewID);\n            callback(bufferViewData);\n        }\n    }\n    _checkComplete()\n    {\n        if (this._bufferRequested === this._bufferLoaded\n            // && other resources finish loading\n        )\n        {\n            this._loadDone = true;\n        }\n\n        if (this._loadDone && this._parseDone && this._pendingTasks === this._finishedPendingTasks)\n        {\n            this.onload(this.glTF);\n        }\n    }\n\n    _parseGLTF(json)\n    {\n        this.glTF.json = json;\n        this.glTF.defaultScene = json.scene;\n\n        // Iterate through every scene\n        for (const sceneID in json.scenes)\n        {\n            const newScene = new Scene();\n            this.glTF.scenes[sceneID] = newScene;\n\n            const scene = json.scenes[sceneID];\n            const nodes = scene.nodes;\n            const nodeLen = nodes.length;\n\n            // Iterate through every node within scene\n            for (let n = 0; n < nodeLen; ++n)\n            {\n                const nodeName = nodes[n];\n                const node = json.nodes[nodeName];\n\n                // Traverse node\n                this._parseNode(json, node, newScene);\n            }\n        }\n\n        this._parseDone = true;\n        this._checkComplete();\n    }\n\n    _parseNode(json, node, newScene, matrix?)\n    {\n        if (matrix === undefined)\n        {\n            matrix = mat4.create();\n        }\n\n        const curMatrix = mat4.create();\n\n        if (node.hasOwnProperty(\"matrix\"))\n        {\n            // matrix\n            for (let i = 0; i < 16; ++i)\n            {\n                curMatrix[i] = node.matrix[i];\n            }\n            mat4.multiply(curMatrix, matrix, curMatrix);\n            //mat4.multiply(curMatrix, curMatrix, matrix);\n        }\n        else\n        {\n            // translation, rotation, scale (TRS)\n            // TODO: these labels are optional\n            vec3.set(translationVec3, node.translation[0], node.translation[1], node.translation[2]);\n            quat.set(rotationQuat, node.rotation[0], node.rotation[1], node.rotation[2], node.rotation[3]);\n            mat4.fromRotationTranslation(TRMatrix, rotationQuat, translationVec3);\n            mat4.multiply(curMatrix, curMatrix, TRMatrix);\n            vec3.set(scaleVec3, node.scale[0], node.scale[1], node.scale[2]);\n            mat4.scale(curMatrix, curMatrix, scaleVec3);\n        }\n\n        // Iterate through every mesh within node\n        const meshes = node.meshes;\n        if (meshes)\n        {\n            const meshLen = meshes.length;\n            for (let m = 0; m < meshLen; ++m)\n            {\n                const newMesh = new Mesh();\n                newScene.meshes.push(newMesh);\n\n                const meshName = meshes[m];\n                const mesh = json.meshes[meshName];\n\n                newMesh.meshID = meshName;\n\n                // Iterate through primitives\n                const primitives = mesh.primitives;\n                const primitiveLen = primitives.length;\n\n                for (let p = 0; p < primitiveLen; ++p)\n                {\n                    const newPrimitive = new Primitive();\n                    newMesh.primitives.push(newPrimitive);\n\n                    const primitive = primitives[p];\n\n                    if (primitive.indices)\n                    {\n                        this._parseIndices(json, primitive, newPrimitive);\n                    }\n\n                    this._parseAttributes(json, primitive, newPrimitive, curMatrix);\n                }\n            }\n        }\n\n        // Go through all the children recursively\n        const children = node.children;\n        const childreLen = children.length;\n        for (let c = 0; c < childreLen; ++c)\n        {\n            const childName = children[c];\n            const childNode = json.nodes[childName];\n            this._parseNode(json, childNode, newScene, curMatrix);\n        }\n    }\n\n    _parseIndices(json, primitive, newPrimitive: Primitive)\n    {\n        const accessorName = primitive.indices;\n        const accessor = json.accessors[accessorName];\n\n        newPrimitive.mode = primitive.mode || 4;\n        newPrimitive.indicesComponentType = IDrawElementType2Name[accessor.componentType];\n\n        const loader = this;\n        this._getBufferViewData(json, accessor.bufferView, function (bufferViewData)\n        {\n            newPrimitive.indices = _getAccessorData(bufferViewData, accessor) as any;\n            loader._checkComplete();\n        });\n    }\n\n    _parseAttributes(json, primitive, newPrimitive: Primitive, matrix)\n    {\n        // !! Assume interleaved vertex attributes\n        // i.e., all attributes share one bufferView\n\n        // vertex buffer processing\n        const firstSemantic = Object.keys(primitive.attributes)[0];\n        const firstAccessor = json.accessors[primitive.attributes[firstSemantic]];\n        const vertexBufferViewID = firstAccessor.bufferView;\n        const bufferView = json.bufferViews[vertexBufferViewID];\n\n        const loader = this;\n\n        this._getBufferViewData(json, vertexBufferViewID, function (bufferViewData)\n        {\n            const data = newPrimitive.vertexBuffer = _arrayBuffer2TypedArray(\n                bufferViewData,\n                0,\n                bufferView.byteLength / ComponentType2ByteSize[firstAccessor.componentType],\n                firstAccessor.componentType\n            );\n\n            for (const attributeName in primitive.attributes)\n            {\n                const accessorName = primitive.attributes[attributeName];\n                const accessor = json.accessors[accessorName];\n\n                const componentTypeByteSize = ComponentType2ByteSize[accessor.componentType];\n\n                const stride = accessor.byteStride / componentTypeByteSize;\n                const offset = accessor.byteOffset / componentTypeByteSize;\n                const count = accessor.count;\n\n                // // Matrix transformation\n                // if (attributeName === 'POSITION') {\n                //     for (var i = 0; i < count; ++i) {\n                //         // TODO: add vec2 and other(needed?) support\n                //         vec4.set(tmpVec4, data[stride * i + offset]\n                //                         , data[stride * i + offset + 1]\n                //                         , data[stride * i + offset + 2]\n                //                         , 1);\n                //         vec4.transformMat4(tmpVec4, tmpVec4, matrix);\n                //         vec4.scale(tmpVec4, tmpVec4, 1 / tmpVec4[3]);\n                //         data[stride * i + offset] = tmpVec4[0];\n                //         data[stride * i + offset + 1] = tmpVec4[1];\n                //         data[stride * i + offset + 2] = tmpVec4[2];\n                //     }\n                // }\n                // else if (attributeName === 'NORMAL') {\n                //     mat4.invert(inverseTransposeMatrix, matrix);\n                //     mat4.transpose(inverseTransposeMatrix, inverseTransposeMatrix);\n\n                //     for (var i = 0; i < count; ++i) {\n                //         // @todo: add vec2 and other(needed?) support\n                //         vec4.set(tmpVec4, data[stride * i + offset]\n                //                         , data[stride * i + offset + 1]\n                //                         , data[stride * i + offset + 2]\n                //                         , 0);\n                //         vec4.transformMat4(tmpVec4, tmpVec4, inverseTransposeMatrix);\n                //         vec4.normalize(tmpVec4, tmpVec4);\n                //         data[stride * i + offset] = tmpVec4[0];\n                //         data[stride * i + offset + 1] = tmpVec4[1];\n                //         data[stride * i + offset + 2] = tmpVec4[2];\n                //     }\n                // }\n\n                // local transform matrix\n\n                mat4.copy(newPrimitive.matrix, matrix);\n\n                // for vertexAttribPointer\n                newPrimitive.attributes[attributeName] = {\n                    //GLuint program location,\n                    size: Type2NumOfComponent[accessor.type],\n                    type: accessor.componentType,\n                    //GLboolean normalized\n                    stride: accessor.byteStride,\n                    offset: accessor.byteOffset\n                };\n            }\n\n            loader._checkComplete();\n        });\n    }\n\n    /**\n     * load a glTF model\n     *\n     * @param {String} uri uri of the .glTF file. Other resources (bins, images) are assumed to be in the same base path\n     * @param {Function} callback the onload callback function\n     */\n    loadGLTF(uri, callback)\n    {\n        this._init();\n\n        this.onload = callback || ((glTF) =>\n        {\n            console.log(\"glTF model loaded.\");\n            console.log(glTF);\n        });\n\n        this.glTF = new GlTFModel();\n\n        this.baseUri = _getBaseUri(uri);\n\n        const loader = this;\n\n        _loadJSON(uri, function (response)\n        {\n            // Parse JSON string into object\n            const json = JSON.parse(response);\n\n            let b;\n\n            const loadArrayBufferCallback = (resource) =>\n            {\n                loader._buffers[b] = resource;\n                loader._bufferLoaded++;\n                if (loader._bufferTasks[b])\n                {\n                    let i; let len;\n                    for (i = 0, len = loader._bufferTasks[b].length; i < len; ++i)\n                    {\n                        (loader._bufferTasks[b][i])(resource);\n                    }\n                }\n                loader._checkComplete();\n            };\n\n            // Launch loading resources: buffers, images, etc.\n            if (json.buffers)\n            {\n                for (b in json.buffers)\n                {\n                    loader._bufferRequested++;\n\n                    _loadArrayBuffer(`${loader.baseUri}/${json.buffers[b].uri}`, loadArrayBufferCallback);\n                }\n            }\n\n            // Meanwhile start glTF scene parsing\n            loader._parseGLTF(json);\n        });\n    }\n}\n\nconst translationVec3 = vec3.create();\nconst rotationQuat = quat.create();\nconst scaleVec3 = vec3.create();\nconst TRMatrix = mat4.create();\n\n// TODO: get from gl context\nconst ComponentType2ByteSize = {\n    5120: 1, // BYTE\n    5121: 1, // UNSIGNED_BYTE\n    5122: 2, // SHORT\n    5123: 2, // UNSIGNED_SHORT\n    5126: 4 // FLOAT\n};\n\nconst Type2NumOfComponent = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16\n};\n\nconst IDrawElementType2Name = {\n    5121: \"UNSIGNED_BYTE\",\n    5123: \"UNSIGNED_SHORT\",\n    5124: \"UNSIGNED_INT\",\n};\n\nexport const Attributes = [\n    \"POSITION\",\n    \"NORMAL\",\n    \"TEXCOORD\",\n    \"COLOR\",\n    \"JOINT\",\n    \"WEIGHT\"\n];\n\n// ------ Scope limited private util functions---------------\n\nfunction _arrayBuffer2TypedArray(resource, byteOffset, countOfComponentType, componentType)\n{\n    switch (componentType)\n    {\n        // @todo: finish\n        case 5122: return new Int16Array(resource, byteOffset, countOfComponentType);\n        case 5123: return new Uint16Array(resource, byteOffset, countOfComponentType);\n        case 5126: return new Float32Array(resource, byteOffset, countOfComponentType);\n        default: return null;\n    }\n}\n\nfunction _getAccessorData(bufferViewData, accessor)\n{\n    return _arrayBuffer2TypedArray(\n        bufferViewData,\n        accessor.byteOffset,\n        accessor.count * Type2NumOfComponent[accessor.type],\n        accessor.componentType\n    );\n}\n\nfunction _getBaseUri(uri)\n{\n    // https://github.com/AnalyticalGraphicsInc/cesium/blob/master/Source/Core/getBaseUri.js\n\n    let basePath = \"\";\n    const i = uri.lastIndexOf(\"/\");\n    if (i !== -1)\n    {\n        basePath = uri.substring(0, i + 1);\n    }\n\n    return basePath;\n}\n\nfunction _loadJSON(src, callback)\n{\n    // native json loading technique from @KryptoniteDove:\n    // http://codepen.io/KryptoniteDove/post/load-json-file-locally-using-pure-javascript\n\n    const xobj = new XMLHttpRequest();\n    xobj.overrideMimeType(\"application/json\");\n    xobj.open(\"GET\", src, true);\n    xobj.onreadystatechange = function ()\n    {\n        if (xobj.readyState === 4 // Request finished, response ready\n            && xobj.status === 200)\n        { // Status OK\n            callback(xobj.responseText, this);\n        }\n    };\n    xobj.send(null);\n}\n\nfunction _loadArrayBuffer(url, callback)\n{\n    const xobj = new XMLHttpRequest();\n    xobj.responseType = \"arraybuffer\";\n    xobj.open(\"GET\", url, true);\n    xobj.onreadystatechange = function ()\n    {\n        if (xobj.readyState === 4 // Request finished, response ready\n            && xobj.status === 200)\n        { // Status OK\n            const arrayBuffer = xobj.response;\n            if (arrayBuffer && callback)\n            {\n                callback(arrayBuffer);\n            }\n        }\n    };\n    xobj.send(null);\n}"],"names":["create","out","glMatrix.ARRAY_TYPE","set","x","y","z","w","normalize","a","len","vec","stride","offset","count","fn","arg","i","setAxisAngle","axis","rad","s","slerp","b","t","ax","ay","az","aw","bx","by","bz","bw","omega","cosom","sinom","scale0","scale1","glMatrix.EPSILON","fromMat3","m","fTrace","fRoot","j","k","vec4.set","vec4.normalize","tmpvec3","vec3.create","xUnitVec3","vec3.fromValues","yUnitVec3","dot","vec3.dot","vec3.cross","vec3.len","vec3.normalize","temp1","temp2","c","d","matr","mat3.create","view","right","up","Scene","__publicField","Mesh","Primitive","mat4.create","GlTFModel","GlTFLoader","json","bufferViewID","callback","bufferViewData","bufferView","bufferData","bufferTask","loader","newBufferData","curBufferViewData","sceneID","newScene","nodes","nodeLen","n","nodeName","node","matrix","curMatrix","mat4.multiply","vec3.set","translationVec3","quat.set","rotationQuat","mat4.fromRotationTranslation","TRMatrix","scaleVec3","mat4.scale","meshes","meshLen","newMesh","meshName","mesh","primitives","primitiveLen","newPrimitive","primitive","children","childreLen","childName","childNode","accessorName","accessor","IDrawElementType2Name","_getAccessorData","firstSemantic","firstAccessor","vertexBufferViewID","_arrayBuffer2TypedArray","ComponentType2ByteSize","attributeName","componentTypeByteSize","mat4.copy","Type2NumOfComponent","uri","glTF","_getBaseUri","_loadJSON","response","loadArrayBufferCallback","resource","_loadArrayBuffer","quat.create","byteOffset","countOfComponentType","componentType","basePath","src","xobj","url","arrayBuffer"],"mappings":"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","x_google_ignoreList":[0,1,2]}