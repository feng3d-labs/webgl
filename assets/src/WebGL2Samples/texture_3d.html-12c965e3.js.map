{"version":3,"file":"texture_3d.html-12c965e3.js","sources":["../../../../examples/src/WebGL2Samples/texture_3d.ts"],"sourcesContent":["import { reactive } from \"@feng3d/reactivity\";\nimport { CanvasContext, RenderObject, RenderPass, RenderPipeline, Sampler, Texture, VertexAttributes } from \"@feng3d/render-api\";\nimport { WebGL } from \"@feng3d/webgl\";\nimport { snoise } from \"./third-party/noise3D\";\nimport { getShaderSource } from \"./utility\";\n\n(function ()\n{\n    const canvas = document.createElement(\"canvas\");\n    canvas.id = \"glcanvas\";\n    canvas.width = Math.min(window.innerWidth, window.innerHeight);\n    canvas.height = canvas.width;\n    document.body.appendChild(canvas);\n\n    const rc: CanvasContext = { canvasId: \"glcanvas\", webGLcontextId: \"webgl2\" };\n    const webgl = new WebGL(rc);\n\n    // -- Divide viewport\n\n    const windowSize = {\n        x: canvas.width,\n        y: canvas.height\n    };\n\n    const Corners = {\n        TOP_LEFT: 0,\n        TOP_RIGHT: 1,\n        BOTTOM_RIGHT: 2,\n        BOTTOM_LEFT: 3,\n        MAX: 4\n    };\n\n    const viewport: { x: number, y: number, z: number, w: number }[] = new Array(Corners.MAX);\n\n    viewport[Corners.BOTTOM_LEFT] = {\n        x: 0,\n        y: 0,\n        z: windowSize.x / 2,\n        w: windowSize.y / 2\n    };\n\n    viewport[Corners.BOTTOM_RIGHT] = {\n        x: windowSize.x / 2,\n        y: 0,\n        z: windowSize.x / 2,\n        w: windowSize.y / 2\n    };\n\n    viewport[Corners.TOP_RIGHT] = {\n        x: windowSize.x / 2,\n        y: windowSize.y / 2,\n        z: windowSize.x / 2,\n        w: windowSize.y / 2\n    };\n\n    viewport[Corners.TOP_LEFT] = {\n        x: 0,\n        y: windowSize.y / 2,\n        z: windowSize.x / 2,\n        w: windowSize.y / 2\n    };\n\n    // -- Initialize texture\n\n    // Note By @kenrussel: The sample was changed from R32F to R8 for best portability.\n    // not all devices can render to floating-point textures\n    // (and, further, this functionality is in a WebGL extension: EXT_color_buffer_float),\n    // and renderability is a requirement for generating mipmaps.\n\n    const SIZE = 32;\n    const data = new Uint8Array(SIZE * SIZE * SIZE);\n    for (let k = 0; k < SIZE; ++k)\n    {\n        for (let j = 0; j < SIZE; ++j)\n        {\n            for (let i = 0; i < SIZE; ++i)\n            {\n                data[i + j * SIZE + k * SIZE * SIZE] = snoise([i, j, k]) * 256;\n            }\n        }\n    }\n\n    const texture: Texture = {\n        size: [SIZE, SIZE, SIZE],\n        dimension: \"3d\",\n        format: \"r8unorm\",\n        generateMipmap: true,\n        sources: [{ __type__: \"TextureDataSource\", mipLevel: 0, size: [SIZE, SIZE, SIZE], data }],\n    };\n    const sampler: Sampler = {\n        lodMinClamp: 0,\n        lodMaxClamp: Math.log2(SIZE),\n        minFilter: \"linear\",\n        magFilter: \"linear\",\n        mipmapFilter: \"linear\",\n    };\n\n    // -- Initialize program\n    const program: RenderPipeline = { vertex: { code: getShaderSource(\"vs\") }, fragment: { code: getShaderSource(\"fs\") } };\n\n    // -- Initialize buffer\n    const positions = new Float32Array([\n        -1.0, -1.0,\n        1.0, -1.0,\n        1.0, 1.0,\n        1.0, 1.0,\n        -1.0, 1.0,\n        -1.0, -1.0\n    ]);\n\n    const texCoords = new Float32Array([\n        0.0, 1.0,\n        1.0, 1.0,\n        1.0, 0.0,\n        1.0, 0.0,\n        0.0, 0.0,\n        0.0, 1.0\n    ]);\n\n    // -- Initilize vertex array\n\n    const vertexArray: { vertices?: VertexAttributes } = {\n        vertices: {\n            position: { data: positions, format: \"float32x2\" },\n            in_texcoord: { data: texCoords, format: \"float32x2\" },\n        }\n    };\n\n    // -- Render\n\n    const orientation = [0.0, 0.0, 0.0];\n\n    requestAnimationFrame(render);\n\n    function yawPitchRoll(yaw, pitch, roll)\n    {\n        const cosYaw = Math.cos(yaw);\n        const sinYaw = Math.sin(yaw);\n        const cosPitch = Math.cos(pitch);\n        const sinPitch = Math.sin(pitch);\n        const cosRoll = Math.cos(roll);\n        const sinRoll = Math.sin(roll);\n\n        return [\n            cosYaw * cosPitch,\n            cosYaw * sinPitch * sinRoll - sinYaw * cosRoll,\n            cosYaw * sinPitch * cosRoll + sinYaw * sinRoll,\n            0.0,\n            sinYaw * cosPitch,\n            sinYaw * sinPitch * sinRoll + cosYaw * cosRoll,\n            sinYaw * sinPitch * cosRoll - cosYaw * sinRoll,\n            0.0,\n            -sinPitch,\n            cosPitch * sinRoll,\n            cosPitch * cosRoll,\n            0.0,\n            0.0, 0.0, 0.0, 1.0\n        ];\n    }\n\n    const ro: RenderObject = {\n        pipeline: program,\n        bindingResources: {\n            diffuse: { texture, sampler },\n        },\n        vertices: vertexArray.vertices,\n        draw: { __type__: \"DrawVertex\", vertexCount: 6 }\n    };\n\n    const renderPassObjects: RenderObject[] = [];\n    for (let i = 0; i < Corners.MAX; ++i)\n    {\n        renderPassObjects.push({\n            ...ro,\n            viewport: { x: viewport[i].x, y: viewport[i].y, width: viewport[i].z, height: viewport[i].w },\n        });\n    }\n\n    const rp: RenderPass = {\n        descriptor: { colorAttachments: [{ clearValue: [0.0, 0.0, 0.0, 1.0], loadOp: \"clear\" }] },\n        renderPassObjects,\n    };\n\n    function render()\n    {\n        orientation[0] += 0.020; // yaw\n        orientation[1] += 0.010; // pitch\n        orientation[2] += 0.005; // roll\n\n        const yawMatrix = new Float32Array(yawPitchRoll(orientation[0], 0.0, 0.0));\n        const pitchMatrix = new Float32Array(yawPitchRoll(0.0, orientation[1], 0.0));\n        const rollMatrix = new Float32Array(yawPitchRoll(0.0, 0.0, orientation[2]));\n        const yawPitchRollMatrix = new Float32Array(yawPitchRoll(orientation[0], orientation[1], orientation[2]));\n        const matrices = [yawMatrix, pitchMatrix, rollMatrix, yawPitchRollMatrix];\n\n        for (let i = 0; i < Corners.MAX; ++i)\n        {\n            reactive(renderPassObjects[i].bindingResources).orientation = matrices[i];\n        }\n\n        webgl.submit({ commandEncoders: [{ passEncoders: [rp] }] });\n\n        requestAnimationFrame(render);\n    }\n})();\n"],"names":["canvas","rc","webgl","WebGL","windowSize","Corners","viewport","SIZE","data","k","j","i","snoise","texture","sampler","program","getShaderSource","positions","texCoords","vertexArray","orientation","render","yawPitchRoll","yaw","pitch","roll","cosYaw","sinYaw","cosPitch","sinPitch","cosRoll","sinRoll","ro","renderPassObjects","rp","yawMatrix","pitchMatrix","rollMatrix","yawPitchRollMatrix","matrices","reactive"],"mappings":"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"}