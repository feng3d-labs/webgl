{"version":3,"file":"sample8.html-d26cfb2b.js","sources":["../../../../examples/src/webgl-examples/sample8.ts"],"sourcesContent":["import { RenderObject, RenderPass, Sampler, Texture } from \"@feng3d/render-api\";\nimport { SamplerTexture, WebGL } from \"@feng3d/webgl\";\nimport { mat4 } from \"gl-matrix\";\n\nlet cubeRotation = 0.0;\n// will set to true when video can be copied to texture\nlet copyVideo = false;\n\nmain();\n\n//\n// Start here\n//\nfunction main()\n{\n    const canvas = document.querySelector(\"#glcanvas\") as HTMLCanvasElement;\n\n    const webgl = new WebGL({ canvasId: \"glcanvas\", webGLcontextId: \"webgl\" });\n\n    // Here's where we call the routine that builds all the\n    // objects we'll be drawing.\n    const buffers = initBuffers();\n\n    const texture = initTexture();\n\n    const video = setupVideo(\"../../Firefox.mp4\");\n\n    const renderObject: RenderObject = {\n        pipeline: {\n            vertex: {\n                code: `\n        attribute vec4 aVertexPosition;\n        attribute vec3 aVertexNormal;\n        attribute vec2 aTextureCoord;\n    \n        uniform mat4 uNormalMatrix;\n        uniform mat4 uModelViewMatrix;\n        uniform mat4 uProjectionMatrix;\n    \n        varying highp vec2 vTextureCoord;\n        varying highp vec3 vLighting;\n    \n        void main(void) {\n          gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\n          vTextureCoord = aTextureCoord;\n    \n          // Apply lighting effect\n    \n          highp vec3 ambientLight = vec3(0.3, 0.3, 0.3);\n          highp vec3 directionalLightColor = vec3(1, 1, 1);\n          highp vec3 directionalVector = normalize(vec3(0.85, 0.8, 0.75));\n    \n          highp vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0);\n    \n          highp float directional = max(dot(transformedNormal.xyz, directionalVector), 0.0);\n          vLighting = ambientLight + (directionalLightColor * directional);\n        }\n      ` }, fragment: {\n                code: `\n        varying highp vec2 vTextureCoord;\n        varying highp vec3 vLighting;\n    \n        uniform sampler2D uSampler;\n    \n        void main(void) {\n          highp vec4 texelColor = texture2D(uSampler, vTextureCoord);\n    \n          gl_FragColor = vec4(texelColor.rgb * vLighting, texelColor.a);\n        }\n      ` },\n            depthStencil: { depthCompare: \"less-equal\" }\n        },\n        geometry: {\n            primitive: { topology: \"triangle-list\" },\n            vertices: {\n                aVertexPosition: {\n                    format: \"float32x3\",\n                    data: buffers.position,\n                },\n                aVertexNormal: {\n                    format: \"float32x3\",\n                    data: buffers.normal,\n                },\n                aTextureCoord: {\n                    format: \"float32x2\",\n                    data: buffers.textureCoord,\n                },\n            },\n            indices: buffers.indices,\n            draw: { __type__: \"DrawIndexed\", firstIndex: 0, indexCount: 36 },\n        },\n        bindingResources: { uSampler: texture },\n    };\n\n    const renderPass: RenderPass = {\n        descriptor: {\n            colorAttachments: [{\n                clearValue: [0.0, 0.0, 0.0, 1.0],\n                loadOp: \"clear\",\n            }],\n            depthStencilAttachment: {\n                depthClearValue: 1.0,\n                depthLoadOp: \"clear\",\n            },\n        },\n        renderObjects: [renderObject],\n    };\n\n    let then = 0;\n\n    // Draw the scene repeatedly\n    function render(now: number)\n    {\n        now *= 0.001; // convert to seconds\n        const deltaTime = now - then;\n        then = now;\n\n        if (copyVideo)\n        {\n            updateTexture(texture.texture, video);\n        }\n\n        const { projectionMatrix, modelViewMatrix, normalMatrix } = drawScene(canvas, deltaTime);\n\n        renderObject.bindingResources.uProjectionMatrix = projectionMatrix;\n        renderObject.bindingResources.uModelViewMatrix = modelViewMatrix;\n        renderObject.bindingResources.uNormalMatrix = normalMatrix;\n\n        webgl.submit({ commandEncoders: [{ passEncoders: [renderPass] }] });\n\n        requestAnimationFrame(render);\n    }\n    requestAnimationFrame(render);\n}\n\nfunction setupVideo(url: string)\n{\n    const video = document.createElement(\"video\");\n\n    let playing = false;\n    let timeupdate = false;\n\n    video.autoplay = true;\n    video.muted = true;\n    video.loop = true;\n\n    // Waiting for these 2 events ensures\n    // there is data in the video\n\n    video.addEventListener(\"playing\", function ()\n    {\n        playing = true;\n        checkReady();\n    }, true);\n\n    video.addEventListener(\"timeupdate\", function ()\n    {\n        timeupdate = true;\n        checkReady();\n    }, true);\n\n    video.src = url;\n    video.play();\n\n    function checkReady()\n    {\n        if (playing && timeupdate)\n        {\n            copyVideo = true;\n        }\n    }\n\n    return video;\n}\n\n//\n// initBuffers\n//\n// Initialize the buffers we'll need. For this demo, we just\n// have one object -- a simple three-dimensional cube.\n//\nfunction initBuffers()\n{\n    // Now create an array of positions for the cube.\n\n    const positions = [\n        // Front face\n        -1.0, -1.0, 1.0,\n        1.0, -1.0, 1.0,\n        1.0, 1.0, 1.0,\n        -1.0, 1.0, 1.0,\n\n        // Back face\n        -1.0, -1.0, -1.0,\n        -1.0, 1.0, -1.0,\n        1.0, 1.0, -1.0,\n        1.0, -1.0, -1.0,\n\n        // Top face\n        -1.0, 1.0, -1.0,\n        -1.0, 1.0, 1.0,\n        1.0, 1.0, 1.0,\n        1.0, 1.0, -1.0,\n\n        // Bottom face\n        -1.0, -1.0, -1.0,\n        1.0, -1.0, -1.0,\n        1.0, -1.0, 1.0,\n        -1.0, -1.0, 1.0,\n\n        // Right face\n        1.0, -1.0, -1.0,\n        1.0, 1.0, -1.0,\n        1.0, 1.0, 1.0,\n        1.0, -1.0, 1.0,\n\n        // Left face\n        -1.0, -1.0, -1.0,\n        -1.0, -1.0, 1.0,\n        -1.0, 1.0, 1.0,\n        -1.0, 1.0, -1.0,\n    ];\n\n    // Set up the normals for the vertices, so that we can compute lighting.\n\n    const vertexNormals = [\n        // Front\n        0.0, 0.0, 1.0,\n        0.0, 0.0, 1.0,\n        0.0, 0.0, 1.0,\n        0.0, 0.0, 1.0,\n\n        // Back\n        0.0, 0.0, -1.0,\n        0.0, 0.0, -1.0,\n        0.0, 0.0, -1.0,\n        0.0, 0.0, -1.0,\n\n        // Top\n        0.0, 1.0, 0.0,\n        0.0, 1.0, 0.0,\n        0.0, 1.0, 0.0,\n        0.0, 1.0, 0.0,\n\n        // Bottom\n        0.0, -1.0, 0.0,\n        0.0, -1.0, 0.0,\n        0.0, -1.0, 0.0,\n        0.0, -1.0, 0.0,\n\n        // Right\n        1.0, 0.0, 0.0,\n        1.0, 0.0, 0.0,\n        1.0, 0.0, 0.0,\n        1.0, 0.0, 0.0,\n\n        // Left\n        -1.0, 0.0, 0.0,\n        -1.0, 0.0, 0.0,\n        -1.0, 0.0, 0.0,\n        -1.0, 0.0, 0.0,\n    ];\n\n    // Now set up the texture coordinates for the faces.\n\n    const textureCoordinates = [\n        // Front\n        0.0, 0.0,\n        1.0, 0.0,\n        1.0, 1.0,\n        0.0, 1.0,\n        // Back\n        0.0, 0.0,\n        1.0, 0.0,\n        1.0, 1.0,\n        0.0, 1.0,\n        // Top\n        0.0, 0.0,\n        1.0, 0.0,\n        1.0, 1.0,\n        0.0, 1.0,\n        // Bottom\n        0.0, 0.0,\n        1.0, 0.0,\n        1.0, 1.0,\n        0.0, 1.0,\n        // Right\n        0.0, 0.0,\n        1.0, 0.0,\n        1.0, 1.0,\n        0.0, 1.0,\n        // Left\n        0.0, 0.0,\n        1.0, 0.0,\n        1.0, 1.0,\n        0.0, 1.0,\n    ];\n\n    // This array defines each face as two triangles, using the\n    // indices into the vertex array to specify each triangle's\n    // position.\n\n    const indices = [\n        0, 1, 2, 0, 2, 3, // front\n        4, 5, 6, 4, 6, 7, // back\n        8, 9, 10, 8, 10, 11, // top\n        12, 13, 14, 12, 14, 15, // bottom\n        16, 17, 18, 16, 18, 19, // right\n        20, 21, 22, 20, 22, 23, // left\n    ];\n\n    return {\n        position: new Float32Array(positions),\n        normal: new Float32Array(vertexNormals),\n        textureCoord: new Float32Array(textureCoordinates),\n        indices: new Uint16Array(indices),\n    };\n}\n\n//\n// Initialize a texture.\n//\nfunction initTexture(): SamplerTexture\n{\n    const texture: Texture = {\n        size: [1, 1],\n        format: \"rgba8unorm\",\n        sources: [{ __type__: \"TextureDataSource\", size: [1, 1], data: new Uint8Array([0, 0, 255, 255]) }],\n    };\n    const sampler: Sampler = { addressModeU: \"clamp-to-edge\", addressModeV: \"clamp-to-edge\", minFilter: \"linear\" };\n\n    return { texture, sampler };\n}\n\n//\n// copy the video texture\n//\nfunction updateTexture(texture: Texture, video: HTMLVideoElement)\n{\n    // 修改纹理尺寸\n    if (texture.size[0] !== video.videoWidth || texture.size[1] !== video.videoHeight)\n    {\n        texture.size = [video.videoWidth, video.videoHeight];\n    }\n\n    texture.sources = [{ image: video }];\n}\n\n//\n// Draw the scene.\n//\nfunction drawScene(canvas: HTMLCanvasElement, deltaTime: number)\n{\n    // Create a perspective matrix, a special matrix that is\n    // used to simulate the distortion of perspective in a camera.\n    // Our field of view is 45 degrees, with a width/height\n    // ratio that matches the display size of the canvas\n    // and we only want to see objects between 0.1 units\n    // and 100 units away from the camera.\n\n    const fieldOfView = 45 * Math.PI / 180; // in radians\n    const aspect = canvas.clientWidth / canvas.clientHeight;\n    const zNear = 0.1;\n    const zFar = 100.0;\n    const projectionMatrix = mat4.create();\n\n    // note: glmatrix.js always has the first argument\n    // as the destination to receive the result.\n    mat4.perspective(projectionMatrix,\n        fieldOfView,\n        aspect,\n        zNear,\n        zFar);\n\n    // Set the drawing position to the \"identity\" point, which is\n    // the center of the scene.\n    const modelViewMatrix = mat4.create();\n\n    // Now move the drawing position a bit to where we want to\n    // start drawing the square.\n\n    mat4.translate(modelViewMatrix, // destination matrix\n        modelViewMatrix, // matrix to translate\n        [-0.0, 0.0, -6.0]); // amount to translate\n    mat4.rotate(modelViewMatrix, // destination matrix\n        modelViewMatrix, // matrix to rotate\n        cubeRotation, // amount to rotate in radians\n        [0, 0, 1]); // axis to rotate around (Z)\n    mat4.rotate(modelViewMatrix, // destination matrix\n        modelViewMatrix, // matrix to rotate\n        cubeRotation * 0.7, // amount to rotate in radians\n        [0, 1, 0]); // axis to rotate around (X)\n\n    const normalMatrix = mat4.create();\n    mat4.invert(normalMatrix, modelViewMatrix);\n    mat4.transpose(normalMatrix, normalMatrix);\n\n    // Update the rotation for the next draw\n\n    cubeRotation += deltaTime;\n\n    return { projectionMatrix, modelViewMatrix, normalMatrix };\n}\n\n"],"names":["cubeRotation","copyVideo","main","canvas","webgl","WebGL","buffers","initBuffers","texture","initTexture","video","setupVideo","renderObject","renderPass","then","render","now","deltaTime","updateTexture","projectionMatrix","modelViewMatrix","normalMatrix","drawScene","url","playing","timeupdate","checkReady","positions","vertexNormals","textureCoordinates","indices","fieldOfView","aspect","zNear","zFar","mat4.create","mat4.perspective","mat4.translate","mat4.rotate","mat4.invert","mat4.transpose"],"mappings":"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"}